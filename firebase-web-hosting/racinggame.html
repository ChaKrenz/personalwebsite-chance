<!DOCTYPE html>
<html>
<head>
    <title>2D Racing Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            background: #2c3e50;
            font-family: Arial, sans-serif;
            color: white;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            margin: 20px;
        }
        #gameCanvas {
            border: 2px solid white;
            background: #95a5a6;
        }
        #timer {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 24px;
            z-index: 10;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
        }
        #leaderboard {
            margin: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            min-width: 250px;
        }
        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        .place {
            font-weight: bold;
            margin-right: 10px;
        }
        .gold { color: #FFD700; }
        .silver { color: #C0C0C0; }
        .bronze { color: #CD7F32; }
        #gameOverMessage {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
        }
        #restartButton {
            margin-top: 10px;
            padding: 10px 20px;
            background: #4CAF50;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }
        #restartButton:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="timer">Time: 0.00s</div>
        <div id="controls">
            <ul style="list-style-type: none; padding-left: 0;">
                <li><span style="display:inline-block; width: 20px;">↑</span>Accelerate</li>
                <li><span style="display:inline-block; width: 20px;">↓</span>Brake/Reverse</li>
                <li><span style="display:inline-block; width: 20px;">←</span>Turn Left</li>
                <li><span style="display:inline-block; width: 20px;">→</span>Turn Right</li>
            </ul>
        </div>
        <div id="gameOverMessage">
            <h2>Race Complete!</h2>
            <p id="finalTimeDisplay"></p>
            <button id="restartButton">Race Again</button>
        </div>
    </div>
    <div id="leaderboard">
        <h2>Top 10 Times</h2>
        <div id="leaderboardEntries"></div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-analytics.js";
        import { 
            getFirestore, 
            collection, 
            getDocs, 
            addDoc,
            query, 
            orderBy, 
            limit 
        } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";
    
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCKGX_pK2c0-XqFss9yxVmGUQOOk49IVC4",
            authDomain: "personalwebsite-chance.firebaseapp.com",
            databaseURL: "https://personalwebsite-chance-default-rtdb.firebaseio.com",
            projectId: "personalwebsite-chance",
            storageBucket: "personalwebsite-chance.appspot.com",
            messagingSenderId: "968150134907",
            appId: "1:968150134907:web:b728c3aa41c92e929432de",
            measurementId: "G-QTYCRH51RW"
        };
    
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const db = getFirestore(app);
        const leaderboardRef = collection(db, 'leaderboard');
    
        // Get username on first visit
        let username = localStorage.getItem('racingUsername');
        if (!username) {
            username = prompt('Enter your username for the leaderboard:');
            if (username) {
                localStorage.setItem('racingUsername', username);
            } else {
                username = 'Anonymous';
                localStorage.setItem('racingUsername', username);
            }
        }
    
        // Function to update leaderboard display
        async function updateLeaderboard() {
            const leaderboardDiv = document.getElementById('leaderboardEntries');
            leaderboardDiv.innerHTML = '';
    
            try {
                // Get all scores ordered by time
                const q = query(leaderboardRef, orderBy('time'), limit(50));  // Increased limit to handle filtering
                const querySnapshot = await getDocs(q);
    
                if (querySnapshot.empty) {
                    leaderboardDiv.textContent = "No leaderboard data available.";
                    return;
                }

                // Process scores to keep only the best time per user
                const bestScores = new Map();  // Use Map to track best score per user
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    if (!bestScores.has(data.username) || 
                        bestScores.get(data.username).time > data.time) {
                        bestScores.set(data.username, data);
                    }
                });

                // Convert to array and sort by time
                const sortedScores = Array.from(bestScores.values())
                    .sort((a, b) => a.time - b.time)
                    .slice(0, 10);  // Keep top 10

                // Display scores
                sortedScores.forEach((data, index) => {
                    const position = index + 1;
                    const entryDiv = document.createElement('div');
                    entryDiv.className = 'leaderboard-entry';

                    const placeSpan = document.createElement('span');
                    placeSpan.className = `place ${position === 1 ? 'gold' : position === 2 ? 'silver' : position === 3 ? 'bronze' : ''}`;
                    placeSpan.textContent = `${position}.`;

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = data.username;

                    const timeSpan = document.createElement('span');
                    timeSpan.textContent = `${data.time.toFixed(2)}s`;

                    entryDiv.appendChild(placeSpan);
                    entryDiv.appendChild(nameSpan);
                    entryDiv.appendChild(timeSpan);
                    leaderboardDiv.appendChild(entryDiv);
                });
                
            } catch (error) {
                console.error("Error fetching leaderboard:", error);
                leaderboardDiv.textContent = "Error fetching leaderboard data.";
            }
        }
    
        // Initial leaderboard load
        updateLeaderboard();
    
        async function submitScore(time) {
            try {
                // Simply add the new score
                await addDoc(leaderboardRef, { 
                    username, 
                    time, 
                    timestamp: Date.now() 
                });
                console.log("New score submitted successfully!");
                
                await updateLeaderboard();
            } catch (error) {
                console.error("Error submitting score:", error);
                alert("Error submitting score. Your time was: " + time.toFixed(2) + "s");
            }
        }
        window.submitScore = submitScore;

        let gameState;
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const gameOverMessage = document.getElementById('gameOverMessage');
            const finalTimeDisplay = document.getElementById('finalTimeDisplay');
            const restartButton = document.getElementById('restartButton');

            // Game constants
            const CAR_WIDTH = 30;
            const CAR_HEIGHT = 50;
            const MAX_SPEED = 5;
            const ACCELERATION = 0.2;
            const BRAKE_POWER = 0.3;
            const TURN_SPEED = 0.05;
            const FRICTION = 0.98;
            const TRACK_WIDTH = 100; // Increased track width
            const FLAG_SIZE = TRACK_WIDTH + 10;

            // Game state
            let gameState = {
                car: {
                    x: 0,
                    y: 0,
                    angle: 0,
                    speed: 0,
                    lap: 0
                },
                track: [],
                startLine: { x: 0, y: 0, angle: 0 },
                isRacing: false,
                time: 0,
                startTime: Date.now(),
                lastCheckpoint: 0,
                raceCompleted: false,  // New flag to prevent multiple submissions
                scoreSubmitted: false  // New flag to prevent multiple submissions
            };

            const keys = {};

            function generateRandomTrack() {
                const points = [];
                const numPoints = 8 + Math.floor(Math.random() * 4); // Randomize the number of points (8-11)
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const minRadius = Math.min(canvas.width, canvas.height) / 4; // Reduced min radius for more irregular shapes
                const maxRadius = Math.min(canvas.width, canvas.height) / 2;

                const straightLength = 150; // Length of the straight section in pixels

                // Generate random control points with randomized angles and radii
                for (let i = 0; i < numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI * 2 + (Math.random() * 0.3 - 0.15); // Randomize angles slightly
                    const radius = minRadius + Math.random() * (maxRadius - minRadius); // Randomize radius between min and max
                    points.push({
                        x: centerX + Math.cos(angle) * radius,
                        y: centerY + Math.sin(angle) * radius
                    });
                }

                // Force the first two points to form a straight line
                const startPoint = points[0];
                const nextPoint = points[1];

                // Calculate angle of the first segment
                const angle = Math.atan2(nextPoint.y - startPoint.y, nextPoint.x - startPoint.x);
                
                // Adjust the second point to ensure a straight line of the desired length
                points[1] = {
                    x: startPoint.x + Math.cos(angle) * straightLength,
                    y: startPoint.y + Math.sin(angle) * straightLength
                };

                // Convert points to smooth track segments using bezier curves
                gameState.track = [];
                const segments = 200;

                for (let i = 0; i < points.length; i++) {
                    const current = points[i];
                    const next = points[(i + 1) % points.length];
                    const prev = points[(i - 1 + points.length) % points.length];

                    // Calculate control points for smoother curves
                    const cp1x = current.x + (next.x - prev.x) * 0.25;
                    const cp1y = current.y + (next.y - prev.y) * 0.25;
                    const cp2x = next.x - (next.x - current.x) * 0.25;
                    const cp2y = next.y - (next.y - current.y) * 0.25;

                    for (let j = 0; j < segments / points.length; j++) {
                        const t = j / (segments / points.length);
                        const point = bezierPoint(current, {x: cp1x, y: cp1y}, {x: cp2x, y: cp2y}, next, t);
                        gameState.track.push(point);
                    }
                }

                // Set start line near the first point
                gameState.startLine = {
                    x: gameState.track[0].x,
                    y: gameState.track[0].y,
                    angle: Math.atan2(
                        gameState.track[1].y - gameState.track[0].y,
                        gameState.track[1].x - gameState.track[0].x
                    )
                };

                // Set car starting position
                gameState.car.x = gameState.startLine.x;
                gameState.car.y = gameState.startLine.y;
                gameState.car.angle = -gameState.startLine.angle;
            }


            function bezierPoint(p0, p1, p2, p3, t) {
                const cX = 3 * (p1.x - p0.x);
                const bX = 3 * (p2.x - p1.x) - cX;
                const aX = p3.x - p0.x - cX - bX;
                
                const cY = 3 * (p1.y - p0.y);
                const bY = 3 * (p2.y - p1.y) - cY;
                const aY = p3.y - p0.y - cY - bY;
                
                const x = (aX * Math.pow(t, 3)) + (bX * Math.pow(t, 2)) + (cX * t) + p0.x;
                const y = (aY * Math.pow(t, 3)) + (bY * Math.pow(t, 2)) + (cY * t) + p0.y;
                
                return {x, y};
            }

            function drawCheckeredFlag() {
                const flagWidth = FLAG_SIZE; // Flag width is the original flag size
                const flagLength = flagWidth / 4; // Length is one-fourth of the width
                const rows = 4; // More rows for smaller squares
                const cols = 8; // More columns for smaller squares
                const squareWidth = flagWidth / cols;
                const squareLength = flagLength / rows;

                ctx.save();
                ctx.translate(gameState.startLine.x, gameState.startLine.y);
                
                // Rotate the flag by 90 degrees (π/2 radians) to go across the track
                ctx.rotate(gameState.startLine.angle + Math.PI / 2);

                // Draw checkered pattern with smaller squares
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        ctx.fillStyle = (i + j) % 2 === 0 ? 'white' : 'black';
                        ctx.fillRect(
                            -flagWidth / 2 + i * squareWidth,
                            -flagLength / 2 + j * squareLength,
                            squareWidth,
                            squareLength
                        );
                    }
                }

                ctx.restore();
            }

            function drawCar() {
                ctx.save();
                ctx.translate(gameState.car.x, gameState.car.y);
                ctx.rotate(gameState.car.angle + Math.PI/2);
                
                const pixelSize = 4; // Size of each "pixel" block
                
                // Wheels (black)
                ctx.fillStyle = '#000000';
                // Front wheels
                ctx.fillRect(-20, -22, 12, 16);
                ctx.fillRect(-20, 6, 12, 16);
                // Back wheels
                ctx.fillRect(8, -22, 12, 16);
                ctx.fillRect(8, 6, 12, 16);

                //(x: number, y: number, w: number, h: number)

                //wing
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(-16, 20, 32, 6)
                ctx.fillRect(-20, -29, 40, 3)
                
                // Car body main (red)
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(-12, -30, 24, 50);
                
                // Front and back accents (light gray)
                ctx.fillStyle = '#DDDDDD';
                // Front accent
                ctx.fillRect(-12, -16, 8, 32);
                // Back accent
                ctx.fillRect(4, -16, 8, 32);
                
                // Additional black details
                ctx.fillStyle = '#000000';
                // Central stripe
                ctx.fillRect(-4, -26, 8, 44);
                // Front detail
                ctx.fillRect(-15, -8, 4, 16);
                // Back detail
                ctx.fillRect(11, -8, 4, 16);
                
                ctx.restore();
            }

            function drawTrack() {
                ctx.beginPath();
                ctx.moveTo(gameState.track[0].x, gameState.track[0].y);
                
                for (let i = 1; i < gameState.track.length; i++) {
                    ctx.lineTo(gameState.track[i].x, gameState.track[i].y);
                }
                
                ctx.closePath();
                ctx.strokeStyle = '#666';
                ctx.lineWidth = TRACK_WIDTH;
                ctx.stroke();
                
                // Track borders
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            async function checkLap() {
                const dx = gameState.car.x - gameState.startLine.x;
                const dy = gameState.car.y - gameState.startLine.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < TRACK_WIDTH/2) {
                    const currentCheckpoint = getNearestTrackPoint(gameState.car.x, gameState.car.y);
                    if (Math.abs(currentCheckpoint - gameState.lastCheckpoint) > gameState.track.length/2) {
                        gameState.lap++;
                        if (gameState.lap >= 3 && !gameState.raceCompleted) {
                            gameState.raceCompleted = true;
                            const finalTime = gameState.time;
                            
                            // Show game over message
                            finalTimeDisplay.textContent = `Your time: ${finalTime.toFixed(2)}s`;
                            gameOverMessage.style.display = 'block';
                            
                            // Submit score only once
                            if (!gameState.scoreSubmitted) {
                                gameState.scoreSubmitted = true;
                                await submitScore(finalTime);
                            }
                        }
                    }
                    gameState.lastCheckpoint = currentCheckpoint;
                }
            }

            function update() {
                // Fixed controls for proper car movement
                if (keys.ArrowUp) {
                    // Accelerate forward
                    gameState.car.speed += ACCELERATION;
                }
                if (keys.ArrowDown) {
                    // Brake/reverse
                    if (gameState.car.speed > 0) {
                        gameState.car.speed -= BRAKE_POWER; // Stronger brake effect
                    } else {
                        gameState.car.speed -= ACCELERATION / 4; // Slower reverse
                    }
                }
                
                // Only allow turning when the car is moving
                if (Math.abs(gameState.car.speed) > 0.1) {
                    if (keys.ArrowLeft) {
                        gameState.car.angle -= TURN_SPEED * (gameState.car.speed > 0 ? 1 : -1);
                    }
                    if (keys.ArrowRight) {
                        gameState.car.angle += TURN_SPEED * (gameState.car.speed > 0 ? 1 : -1);
                    }
                }

                gameState.car.speed *= FRICTION;
                gameState.car.speed = Math.max(-MAX_SPEED/2, Math.min(MAX_SPEED, gameState.car.speed));

                const newX = gameState.car.x + Math.cos(gameState.car.angle) * gameState.car.speed;
                const newY = gameState.car.y + Math.sin(gameState.car.angle) * gameState.car.speed;
                
                const nearestPoint = getNearestTrackPoint(newX, newY);
                if (isPointInTrack(newX, newY, nearestPoint)) {
                    gameState.car.x = newX;
                    gameState.car.y = newY;
                    checkLap();
                } else {
                    gameState.car.speed *= 0.5; // Softer collision response
                }

                if (gameState.isRacing) {
                    gameState.time = (Date.now() - gameState.startTime) / 1000;
                    document.getElementById('timer').textContent = `Time: ${gameState.time.toFixed(2)}s`;
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawTrack();
                drawCheckeredFlag();
                drawCar();
                
                ctx.fillStyle = 'white';
                ctx.font = '24px Arial';
                ctx.fillText(`Lap: ${gameState.lap + 1}/3`, 20, 40);
            }

            function getNearestTrackPoint(x, y) {
                let nearest = 0;
                let minDist = Infinity;
                
                for (let i = 0; i < gameState.track.length; i++) {
                    const dx = x - gameState.track[i].x;
                    const dy = y - gameState.track[i].y;
                    const dist = dx * dx + dy * dy;
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = i;
                    }
                }
                return nearest;
            }

            function isPointInTrack(x, y, nearestPoint) {
                const point = gameState.track[nearestPoint];
                const dx = x - point.x;
                const dy = y - point.y;
                return Math.sqrt(dx * dx + dy * dy) < TRACK_WIDTH/2;
            }

            function gameLoop() {
                update();
                draw();

                if (gameState.isRacing) {
                    gameState.time = (Date.now() - gameState.startTime) / 1000;
                    document.getElementById('timer').textContent = `Time: ${gameState.time.toFixed(2)}s`;

                    // Check for lap completion
                    checkLap();
                }

                requestAnimationFrame(gameLoop);
            }

            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                }
            });

            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });

            restartButton.addEventListener('click', () => {
                gameOverMessage.style.display = 'none';
                initGame();
            });
        
            function initGame() {
                generateRandomTrack();
                gameState.isRacing = true;
                gameState.startTime = Date.now();
                gameState.lap = 0;
                gameState.lastCheckpoint = 0;
                gameState.time = 0;
                gameState.car.speed = 0;
                gameState.raceCompleted = false;
                gameState.scoreSubmitted = false;
            }

            initGame();
            gameLoop();
        });
        window.gameState = gameState;
    </script>
</body>
</html>