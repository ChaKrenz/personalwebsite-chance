<!DOCTYPE html>
<html>
<head>
    <title>Gadget Runner Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a1a;
        }

        #game-container {
            width: 1200px;
            height: 800px;
            position: relative;
            margin: 0 auto;
            background: #1a1a1a;
        }

        .player {
            width: 30px;
            height: 30px;
            background: #4CAF50;
            position: absolute;
            border-radius: 5px;
            transition: opacity 0.15s ease-in-out;
        }

        .player::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            background: #2E7D32;
            border-radius: 50%;
            top: 50%;
            transform: translateY(-50%);
            transition: left right 0.2s ease;
        }

        .player.facing-right::after {
            right: 2px;
        }

        .player.facing-left::after {
            left: 2px;
        }

        .platform {
            position: absolute;
            background: #666;
            border-radius: 3px;
        }

        .lava {
            position: absolute;
            background: #ff4444;
            border-radius: 3px;
        }

        .goal {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #4CAF50;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .tutorial-sign {
            position: absolute;
            background: none;
            color: #333333;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            pointer-events: none;
            z-index: 1000;
            font-size: 32px;
            text-align: center;
            width: 100%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            z-index: 1000;
        }

        #level-display {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: monospace;
            font-size: 24px;
            z-index: 1000;
        }

        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            z-index: 1000;
        }

        .controls-title {
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }

        .control-item {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            gap: 15px;
        }

        .key {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #666;
        }

        @keyframes dash {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .dashing {
            animation: dash 0.3s ease-in-out;
        }

        #leaderboard-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            font-family: monospace;
            min-width: 400px;
            display: none;
            z-index: 1001;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .place {
            font-weight: bold;
            margin-right: 10px;
        }

        .gold { color: #FFD700; }
        .silver { color: #C0C0C0; }
        .bronze { color: #CD7F32; }

        #username-prompt {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            font-family: monospace;
            text-align: center;
            z-index: 1002;
            display: none;
        }

        .input-field {
            margin: 10px 0;
            padding: 8px;
            width: 200px;
            border: none;
            border-radius: 5px;
        }

        .button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-family: monospace;
        }

        .button:hover {
            background: #45a049;
        }

        #quotaMessage {
            color: #ff4444;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 68, 68, 0.1);
            border-radius: 5px;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Rest of the HTML remains the same until the createLevel function -->
    <div id="game-container">
        <div id="level-display">Level 1</div>
        <div id="timer-display" style="position: fixed; top: 40px; left: 50%; transform: translateX(-50%); color: white; font-family: monospace; font-size: 24px; z-index: 1000;">Time: 00:00.00</div>
        <div id="hud"></div>
        <div id="controls">
            <div class="controls-title">CONTROLS</div>
            <div class="control-item">
                <span class="key">←</span>
                <span>Move Left</span>
            </div>
            <div class="control-item">
                <span class="key">→</span>
                <span>Move Right</span>
            </div>
            <div class="control-item">
                <span class="key">↑</span>
                <span>Jump/Double Jump</span>
            </div>
            <div class="control-item">
                <span class="key">C</span>
                <span>Dash</span>
            </div>
        </div>
    </div>

    <div id="username-prompt">
        <h2>Enter Your Username</h2>
        <input type="text" id="username-input" class="input-field" maxlength="20" placeholder="Username">
        <button id="username-submit" class="button">Submit</button>
    </div>

    <div id="leaderboard-container">
        <h2 style="text-align: center;">Top 10 Times</h2>
        <div id="quotaMessage">Database quota reached. Your time was recorded locally.</div>
        <div id="leaderboard-entries"></div>
        <div style="text-align: center; margin-top: 20px;">
            <button id="play-again" class="button">Play Again</button>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>

    <script>
        // Store original HTML for reset
        const originalHtml = document.getElementById('game-container').innerHTML;

        // Initialize Firebase with compat version
        const firebaseConfig = {
        apiKey: "AIzaSyCKGX_pK2c0-XqFss9yxVmGUQOOk49IVC4",
        authDomain: "personalwebsite-chance.firebaseapp.com",
        projectId: "personalwebsite-chance",
        storageBucket: "personalwebsite-chance.appspot.com",
        messagingSenderId: "968150134907",
        appId: "1:968150134907:web:b728c3aa41c92e929432de"
    };

    // Initialize Firebase with compat version
    firebase.initializeApp(firebaseConfig);
const db = firebase.firestore();
// Change the collection name to be specific to this game
const leaderboardRef = db.collection('platformer-speedrun-leaderboard');

        // Get or prompt for username
        // Remove the duplicate declaration of 'username'

        async function showLeaderboard(currentTime) {
    const leaderboardContainer = document.getElementById('leaderboard-container');
    const leaderboardEntries = document.getElementById('leaderboard-entries');
    const quotaMessage = document.getElementById('quotaMessage');

    leaderboardContainer.style.display = 'block';
    leaderboardEntries.innerHTML = '<div style="text-align: center;">Loading leaderboard...</div>';
    quotaMessage.style.display = 'none';

    try {
        const querySnapshot = await leaderboardRef
            .orderBy('time')
            .limit(30)
            .get();
        
        // Rest of the showLeaderboard function remains the same...
    } catch (error) {
        console.error("Error fetching leaderboard:", error);
        if (error.code === 'permission-denied') {
            leaderboardEntries.innerHTML = '<div style="text-align: center;">Unable to load leaderboard due to permission settings</div>';
        } else if (error.code === 'resource-exhausted' || 
                  error.message.includes('quota') || 
                  error.message.includes('429')) {
            quotaMessage.style.display = 'block';
            leaderboardEntries.innerHTML = '<div style="text-align: center;">Leaderboard temporarily unavailable</div>';
        } else {
            leaderboardEntries.innerHTML = '<div style="text-align: center;">Error loading leaderboard</div>';
        }
    }
}

async function submitScore(time) {
    try {
        const scoreData = {
            username: username || 'Anonymous',
            time: Number(time),
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        };

        // Store locally first
        let localScores = JSON.parse(localStorage.getItem('platformerScores') || '[]');
        localScores.push({
            ...scoreData,
            timestamp: new Date().toISOString()
        });
        localScores.sort((a, b) => a.time - b.time);
        localStorage.setItem('platformerScores', JSON.stringify(localScores));

        // Try to submit to Firebase
        await leaderboardRef.add(scoreData);
        await showLeaderboard(time);
    } catch (error) {
        console.error("Error submitting score:", error);
        // Show local scores if Firebase fails
        showLocalLeaderboard(time);
    }
}

function showLocalLeaderboard(currentTime) {
    const leaderboardContainer = document.getElementById('leaderboard-container');
    const leaderboardEntries = document.getElementById('leaderboard-entries');
    const quotaMessage = document.getElementById('quotaMessage');

    leaderboardContainer.style.display = 'block';
    quotaMessage.style.display = 'block';

    // Get and sort local scores
    const localScores = JSON.parse(localStorage.getItem('platformerScores') || '[]');
    localScores.sort((a, b) => a.time - b.time);

    // Display local scores
    leaderboardEntries.innerHTML = localScores
        .slice(0, 10)
        .map((score, index) => `
            <div class="leaderboard-entry">
                <span class="place ${index < 3 ? ['gold', 'silver', 'bronze'][index] : ''}">${index + 1}</span>
                <span>${score.username}</span>
                <span>${formatTime(score.time)}</span>
            </div>
        `)
        .join('');
}

        // Add play again functionality
        document.getElementById('play-again').addEventListener('click', () => {
            document.getElementById('leaderboard-container').style.display = 'none';
            const container = document.getElementById('game-container');
            container.innerHTML = originalHtml;
            hasGameStarted = false;
            startTime = null;
            currentLevel = 1;
            createLevel(1);
            gameLoop();
        });


        let username = localStorage.getItem('platformerUsername');

        const GRAVITY = 0.5;
        const JUMP_FORCE = 12;
        const MOVE_SPEED = 5;
        const DASH_DISTANCE = 200;
        const DASH_DURATION = 10;

        let isDashing = false;
        let dashStartX = 0;
        let dashTargetX = 0;
        let dashProgress = 0;
        let gameTimer = null;
        let startTime = null;
        let hasGameStarted = false;
        let finalTime = null;
        let currentLevel = 1;
        let canDash = true;
        let spawnPoint = { x: 100, y: 100 };
        let canDoubleJump = true;
        let tutorialSigns = [];
        // Remove the duplicate declaration of 'player'
        // Remove the duplicate declaration of 'isOnGround'
        // Remove the duplicate declaration of 'platforms'
        // Remove the duplicate declaration of 'lavaBlocks'
        // Remove the duplicate declaration of 'goal'

        const keys = {
            left: false,
            right: false,
            up: false
        };

        class GameObject {
            constructor(x, y, width, height, className) {
                this.position = { x, y };
                this.velocity = { x: 0, y: 0 };
                this.width = width;
                this.height = height;
                this.facingRight = true;

                this.element = document.createElement('div');
                this.element.className = className;
                this.element.style.width = `${width}px`;
                this.element.style.height = `${height}px`;
                
                if (className === 'player') {
                    this.element.classList.add('facing-right');
                }
                
                document.getElementById('game-container').appendChild(this.element);
                this.updatePosition();
            }

            updatePosition() {
                this.element.style.left = `${this.position.x}px`;
                this.element.style.top = `${this.position.y}px`;
            }

            setDirection(facingRight) {
                if (this.facingRight !== facingRight) {
                    this.facingRight = facingRight;
                    this.element.classList.remove('facing-right', 'facing-left');
                    this.element.classList.add(facingRight ? 'facing-right' : 'facing-left');
                }
            }

            remove() {
                this.element.remove();
            }

            intersects(other) {
                return this.position.x < other.position.x + other.width &&
                       this.position.x + this.width > other.position.x &&
                       this.position.y < other.position.y + other.height &&
                       this.position.y + this.height > other.position.y;
            }
        }

        function initializeGame() {
            // Clear any existing game objects
            if (player) player.remove();
            platforms.forEach(p => p.remove());
            lavaBlocks.forEach(l => l.remove());
            if (goal) goal.remove();
            tutorialSigns.forEach(s => s.remove());

            // Reset arrays
            platforms = [];
            lavaBlocks = [];
            tutorialSigns = [];

            // Create new player
            player = new GameObject(100, 100, 30, 30, 'player');
            
            // Create first level
            createLevel(1);
            
            // Start game loop
            gameLoop();
        }

        // Add this new function to handle game start
function startGameTimer() {
    if (!hasGameStarted) {
        hasGameStarted = true;
        startTime = Date.now();
        gameTimer = setInterval(updateTimer, 10); // Update every 10ms for smooth display
    }
}

// Add this function to format the time
function formatTime(ms) {
    const totalSeconds = ms / 1000;
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = Math.floor(totalSeconds % 60);
    const milliseconds = Math.floor((ms % 1000) / 10);
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(2, '0')}`;
}

// Add this function to update the timer display
function updateTimer() {
    if (startTime) {
        const currentTime = Date.now();
        const elapsedTime = currentTime - startTime;
        const timerDisplay = document.getElementById('timer-display');
        if (timerDisplay) {
            timerDisplay.textContent = `Time: ${formatTime(elapsedTime)}`;
        }
    }
}

// Make sure createVictoryScreen properly integrates with the leaderboard
function createVictoryScreen(finalTimeMs) {
            if (!username) {
                const usernamePrompt = document.getElementById('username-prompt');
                const usernameInput = document.getElementById('username-input');
                const usernameSubmit = document.getElementById('username-submit');

                usernamePrompt.style.display = 'block';
                usernameInput.focus();

                usernameSubmit.onclick = () => {
                    username = usernameInput.value.trim() || 'Anonymous';
                    localStorage.setItem('platformerUsername', username);
                    usernamePrompt.style.display = 'none';
                    submitScore(finalTimeMs);
                };
            } else {
                submitScore(finalTimeMs);
            }
        }

        // All other functions remain the same but moved after GameObject class definition
        function createTutorialSign(x, y, text) {
            const sign = document.createElement('div');
            sign.className = 'tutorial-sign';
            sign.textContent = text;
            sign.style.left = `${x}px`;
            sign.style.top = `${y}px`;
            sign.style.fontSize = '32px';
            document.getElementById('game-container').appendChild(sign);
            tutorialSigns.push(sign);
        }

        const player = new GameObject(100, 100, 30, 30, 'player');
        let isOnGround = false;
        let platforms = [];
        let lavaBlocks = [];
        let goal = null;

        function createLevel(levelNumber) {
    // Clear existing level
    platforms.forEach(p => p.remove());
    lavaBlocks.forEach(l => l.remove());
    if (goal) goal.remove();
    tutorialSigns.forEach(sign => sign.remove());
    tutorialSigns = [];

    platforms = [];
    lavaBlocks = [];

    // Reset player states
    canDoubleJump = true;
    canDash = true;
    
    // Update level display immediately
    document.getElementById('level-display').textContent = `Level ${levelNumber}`;

    switch(levelNumber) {
        case 1:
            spawnPoint = { x: 50, y: 700 };
            platforms = [
                new GameObject(0, 750, 1200, 20, 'platform')
            ];
            goal = new GameObject(1100, 700, 30, 30, 'goal');
            createTutorialSign(600, 400, "Use ← → to move");
            createTutorialSign(600, 450, "Press ↑ to jump");
            createTutorialSign(600, 500, "Reach the green circle!");
            break;

        case 2:
            spawnPoint = { x: 50, y: 700 };
            platforms = [
                new GameObject(0, 750, 400, 20, 'platform'),
                new GameObject(600, 750, 600, 20, 'platform')
            ];
            lavaBlocks = [
                new GameObject(400, 750, 200, 20, 'lava')
            ];
            goal = new GameObject(1100, 700, 30, 30, 'goal');
            createTutorialSign(600, 400, "Avoid the red lava!");
            break;

        case 3:
            spawnPoint = { x: 50, y: 700 };
            platforms = [
                new GameObject(0, 750, 300, 20, 'platform'),
                new GameObject(500, 750, 300, 20, 'platform'),
                new GameObject(900, 750, 300, 20, 'platform')
            ];
            lavaBlocks = [
                new GameObject(300, 750, 200, 20, 'lava'),
                new GameObject(800, 750, 100, 20, 'lava')
            ];
            goal = new GameObject(1100, 700, 30, 30, 'goal');
            createTutorialSign(600, 400, "Press C to dash!");
            break;

        case 4:
            spawnPoint = { x: 50, y: 700 };
            platforms = [
                new GameObject(0, 750, 400, 20, 'platform'),
                new GameObject(800, 750, 400, 20, 'platform')
            ];
            lavaBlocks = [
                new GameObject(400, 750, 400, 20, 'lava')
            ];
            goal = new GameObject(1100, 700, 30, 30, 'goal');
            createTutorialSign(600, 400, "Press ↑ twice for double jump!");
            break;

        case 5:
            spawnPoint = { x: 50, y: 700 };
            platforms = [
                new GameObject(0, 750, 200, 20, 'platform'),
                new GameObject(400, 600, 200, 20, 'platform'),
                new GameObject(100, 400, 200, 20, 'platform'),
                new GameObject(700, 200, 200, 20, 'platform')
            ];
            lavaBlocks = [
                new GameObject(0, 770, 1200, 20, 'lava')
            ];
            platforms[0].element.style.zIndex = "1";
            goal = new GameObject(1100, 150, 30, 30, 'goal');
            break;

        case 6:
            spawnPoint = { x: 50, y: 700 };
            platforms = [
                new GameObject(0, 750, 200, 20, 'platform'),
                new GameObject(300, 750, 200, 20, 'platform'),
                new GameObject(600, 750, 200, 20, 'platform'),
                new GameObject(900, 750, 200, 20, 'platform'),
                new GameObject(300, 600, 200, 20, 'platform'),
                new GameObject(700, 400, 200, 20, 'platform')
            ];
            lavaBlocks = [
                new GameObject(200, 750, 100, 20, 'lava'),
                new GameObject(500, 750, 100, 20, 'lava'),
                new GameObject(800, 750, 100, 20, 'lava'),
                new GameObject(1100, 750, 100, 20, 'lava')
            ];
            goal = new GameObject(1100, 350, 30, 30, 'goal');
            break;

        case 7:
            spawnPoint = { x: 50, y: 700 };
            platforms = [
                new GameObject(0, 750, 150, 20, 'platform'),
                new GameObject(250, 650, 150, 20, 'platform'),
                new GameObject(500, 500, 150, 20, 'platform'),
                new GameObject(700, 450, 300, 20, 'platform'),
                new GameObject(750, 300, 150, 20, 'platform'),
                new GameObject(1000, 200, 150, 20, 'platform')
            ];
            lavaBlocks = [
                new GameObject(0, 770, 1200, 20, 'lava'),
                new GameObject(400, 600, 500, 20, 'lava'),
                new GameObject(200, 350, 700, 20, 'lava')
            ];
            platforms[0].element.style.zIndex = "1";
            goal = new GameObject(1100, 150, 30, 30, 'goal');
            createTutorialSign(600, 200, "Final challenge!");
            break;
    }

    // Reset player position to spawn point
    player.position = { ...spawnPoint };
    player.velocity = { x: 0, y: 0 };
}

        // Update the dash function to remove cooldown logic
function dash() {
    if (!canDash || isDashing) return;
    
    dashStartX = player.position.x;
    const direction = player.facingRight ? 1 : -1;
    dashTargetX = dashStartX + (DASH_DISTANCE * direction);
    
    isDashing = true;
    dashProgress = 0;
    player.element.classList.add('dashing');
    canDash = false;  // Will be reset when touching ground
}

        function updateDashUI() {
            const dashBar = document.getElementById('dashCooldown');
            dashBar.style.width = `${((DASH_COOLDOWN - dashCooldown) / DASH_COOLDOWN) * 100}%`;
        }

        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowLeft':
                    keys.left = true;
                    break;
                case 'ArrowRight':
                    keys.right = true;
                    break;
                case 'ArrowUp':
                    if (isOnGround) {
                        player.velocity.y = -JUMP_FORCE;
                        canDoubleJump = true;
                    } else if (canDoubleJump) {
                        player.velocity.y = -JUMP_FORCE;
                        canDoubleJump = false;
                    }
                    keys.up = true;
                    break;
                case 'c':
                    if (canDash) {
                        dash();
                    }
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.key) {
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'ArrowUp':
                    keys.up = false;
                    break;
            }
        });

        function checkCollisions() {
    isOnGround = false;
    for (const platform of platforms) {
        if (player.intersects(platform)) {
            if (player.velocity.y > 0 && 
                player.position.y + player.height - player.velocity.y <= platform.position.y) {
                player.position.y = platform.position.y - player.height;
                player.velocity.y = 0;
                isOnGround = true;
                canDoubleJump = true;
                canDash = true;  // Reset dash when touching ground
            } else if (player.velocity.y < 0 && 
                    player.position.y - player.velocity.y >= platform.position.y + platform.height) {
                player.position.y = platform.position.y + platform.height;
                player.velocity.y = 0;
            }
            else if (player.velocity.x > 0 || (isDashing && dashTargetX > dashStartX)) {
                player.position.x = platform.position.x - player.width;
                if (isDashing) {
                    isDashing = false;
                    player.element.classList.remove('dashing');
                }
                player.velocity.x = 0;
            } else if (player.velocity.x < 0 || (isDashing && dashTargetX < dashStartX)) {
                player.position.x = platform.position.x + platform.width;
                if (isDashing) {
                    isDashing = false;
                    player.element.classList.remove('dashing');
                }
                player.velocity.x = 0;
            }
        }
        if (goal && player.intersects(goal)) {
            completeLevel();
        }
    }

    // Updated lava collision handling
    for (const lava of lavaBlocks) {
        if (player.intersects(lava)) {
            // Immediately reset player state
            player.velocity = { x: 0, y: 0 };
            isDashing = false;
            player.element.classList.remove('dashing');
            
            // Reset player abilities
            canDoubleJump = true;
            canDash = true;
            
            // Move player to spawn point
            player.position = { ...spawnPoint };
            
            // Force an immediate position update
            player.updatePosition();
            break;
        }
    }
}

async function completeLevel() {
    if (currentLevel < 7) {
        // Store the next level number
        const nextLevel = currentLevel + 1;
        
        // Immediately reset player position and state
        player.position = { ...spawnPoint };
        player.velocity = { x: 0, y: 0 };
        isDashing = false;
        player.element.classList.remove('dashing');
        
        // Force an immediate position update
        player.updatePosition();
        
        // Small delay to ensure everything is reset
        await new Promise(resolve => setTimeout(resolve, 100));
        
        // Update current level and create the next level
        currentLevel = nextLevel;
        createLevel(currentLevel);
    } else {
        // Stop the timer immediately when reaching the goal in the final level
        if (gameTimer) {
            clearInterval(gameTimer);
            gameTimer = null;
        }
        // Calculate final time right when reaching the goal
        finalTime = Date.now() - startTime;
        
        // Reset states
        player.velocity = { x: 0, y: 0 };
        isDashing = false;
        player.element.classList.remove('dashing');
        
        // Create victory screen with the captured final time
        createVictoryScreen(finalTime);
    }
}
// Modify the key event listeners to start the timer
document.addEventListener('keydown', (e) => {
    switch(e.key) {
        case 'ArrowLeft':
            startGameTimer();
            keys.left = true;
            break;
        case 'ArrowRight':
            startGameTimer();
            keys.right = true;
            break;
        case 'ArrowUp':
            startGameTimer();
            if (isOnGround) {
                player.velocity.y = -JUMP_FORCE;
                canDoubleJump = true;
            } else if (canDoubleJump) {
                player.velocity.y = -JUMP_FORCE;
                canDoubleJump = false;
            }
            keys.up = true;
            break;
        case 'c':
            startGameTimer();
            if (canDash) {
                dash();
            }
            break;
    }
});

        function gameLoop() {
            if (isDashing) {
                dashProgress++;
                
                const t = dashProgress / DASH_DURATION;
                const easeOut = 1 - Math.pow(1 - t, 2);
                player.position.x = dashStartX + (dashTargetX - dashStartX) * easeOut;
                
                if (dashProgress >= DASH_DURATION) {
                    isDashing = false;
                    player.element.classList.remove('dashing');
                }
            } 
            else if (keys.left) {
                player.velocity.x = -MOVE_SPEED;
                player.setDirection(false);
            } else if (keys.right) {
                player.velocity.x = MOVE_SPEED;
                player.setDirection(true);
            } else {
                player.velocity.x = 0;
            }

            player.velocity.y += GRAVITY;

            if (!isDashing) {
                player.position.x += player.velocity.x;
            }
            player.position.y += player.velocity.y;

            checkCollisions();

            const container = document.getElementById('game-container');
            if (player.position.x < 0) {
                player.position.x = 0;
                if (isDashing) {
                    isDashing = false;
                    player.element.classList.remove('dashing');
                }
            }
            if (player.position.x + player.width > container.clientWidth) {
                player.position.x = container.clientWidth - player.width;
                if (isDashing) {
                    isDashing = false;
                    player.element.classList.remove('dashing');
                }
            }
            if (player.position.y < 0) player.position.y = 0;
            if (player.position.y + player.height > container.clientHeight) {
                player.position.y = container.clientHeight - player.height;
                player.velocity.y = 0;
                isOnGround = true;
                canDoubleJump = true;
                canDash = true;  // Reset dash when hitting the floor
            }

            player.updatePosition();
            requestAnimationFrame(gameLoop);
        }

        
        createLevel(currentLevel);
        gameLoop();
        updateDashUI();
    </script>
</body>
</html>