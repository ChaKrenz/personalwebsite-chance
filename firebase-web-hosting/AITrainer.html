<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Training Visualization</title>
    
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.10.3/Recharts.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 p-8">
    <div id="root"></div>

    <script type="text/babel">
        const {
            LineChart,
            Line,
            XAxis,
            YAxis,
            CartesianGrid,
            Tooltip,
            Legend,
            ResponsiveContainer
        } = window.Recharts;

        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 800;
        const MOVE_SPEED = 7;
        const JUMP_FORCE = 13;
        const GRAVITY = 0.7;

        let currentLevelReached = 1;
        const DASH_REWARD = 0.3; // Reward multiplier for dashing

        let currentLevel = 1;

        let spawnPoint = { x: 100, y: 700 };
        const platforms = [
            { position: { x: 0, y: 750 }, width: CANVAS_WIDTH, height: 20 },
            { position: { x: 300, y: 600 }, width: 200, height: 20 },
            { position: { x: 600, y: 500 }, width: 200, height: 20 },
            { position: { x: 900, y: 400 }, width: 200, height: 20 }
        ];
        const lavaBlocks = [
            { position: { x: 400, y: 730 }, width: 100, height: 20 }
        ];
        let goal = {
            position: { x: 1100, y: 350 },
            width: 30,
            height: 30
        };


        class GameObject {
            constructor(x, y, width, height, type) {
                this.position = { x, y };
                this.width = width;
                this.height = height;
                this.type = type; // For example: 'platform', 'goal', or 'lava'
            }
        }

        function createLevel(levelNumber) {
            // Clear existing platforms and lava blocks
            platforms.length = 0;
            lavaBlocks.length = 0;

            switch(levelNumber) {
                case 1: // Basic movement tutorial
                    spawnPoint = { x: 100, y: 700 };
                    platforms.push(new GameObject(0, 750, 1200, 20, 'platform'));
                    goal = new GameObject(1150, 700, 30, 30, 'goal');
                    break;

                case 2: // Jump tutorial
                    spawnPoint = { x: 100, y: 700 };
                    platforms.push(new GameObject(0, 750, 300, 20, 'platform'));
                    platforms.push(new GameObject(400, 700, 200, 20, 'platform'));
                    platforms.push(new GameObject(700, 600, 200, 20, 'platform'));
                    goal = new GameObject(800, 550, 30, 30, 'goal');
                    break;

                case 3: // Double jump tutorial
                    spawnPoint = { x: 100, y: 700 };
                    platforms.push(new GameObject(0, 750, 300, 20, 'platform'));
                    platforms.push(new GameObject(700, 600, 200, 20, 'platform'));
                    goal = new GameObject(800, 550, 30, 30, 'goal');
                    break;

                case 4: // Dash tutorial
                    spawnPoint = { x: 100, y: 700 };
                    platforms.push(new GameObject(0, 750, 300, 20, 'platform'));
                    platforms.push(new GameObject(900, 750, 300, 20, 'platform'));
                    lavaBlocks.push(new GameObject(300, 770, 600, 30, 'lava'));
                    goal = new GameObject(1000, 700, 30, 30, 'goal');
                    break;

                case 5: // Combining jumps and dashes
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 200, 20, 'platform'));
                    platforms.push(new GameObject(400, 650, 150, 20, 'platform'));
                    platforms.push(new GameObject(800, 550, 150, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    goal = new GameObject(850, 500, 30, 30, 'goal');
                    break;

                case 6: // Precision jumping
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 150, 20, 'platform'));
                    platforms.push(new GameObject(300, 650, 100, 20, 'platform'));
                    platforms.push(new GameObject(600, 550, 100, 20, 'platform'));
                    platforms.push(new GameObject(300, 450, 100, 20, 'platform'));
                    platforms.push(new GameObject(600, 350, 100, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    goal = new GameObject(650, 300, 30, 30, 'goal');
                    break;

                case 7: // Speed and timing
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 150, 20, 'platform'));
                    platforms.push(new GameObject(400, 750, 100, 20, 'platform'));
                    platforms.push(new GameObject(800, 650, 100, 20, 'platform'));
                    platforms.push(new GameObject(400, 550, 100, 20, 'platform'));
                    platforms.push(new GameObject(0, 450, 100, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    lavaBlocks.push(new GameObject(500, 670, 300, 30, 'lava'));
                    lavaBlocks.push(new GameObject(100, 570, 300, 30, 'lava'));
                    goal = new GameObject(50, 400, 30, 30, 'goal');
                    break;

                case 8: // Aerial control
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 100, 20, 'platform'));
                    platforms.push(new GameObject(200, 650, 80, 20, 'platform'));
                    platforms.push(new GameObject(400, 550, 80, 20, 'platform'));
                    platforms.push(new GameObject(600, 450, 80, 20, 'platform'));
                    platforms.push(new GameObject(800, 350, 80, 20, 'platform'));
                    platforms.push(new GameObject(1000, 250, 100, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    goal = new GameObject(1050, 200, 30, 30, 'goal');
                    break;

                case 9: // Complex movement
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 150, 20, 'platform'));
                    platforms.push(new GameObject(300, 650, 80, 20, 'platform'));
                    platforms.push(new GameObject(600, 750, 80, 20, 'platform'));
                    platforms.push(new GameObject(900, 650, 80, 20, 'platform'));
                    platforms.push(new GameObject(1100, 550, 100, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    lavaBlocks.push(new GameObject(380, 670, 220, 30, 'lava'));
                    lavaBlocks.push(new GameObject(680, 670, 220, 30, 'lava'));
                    goal = new GameObject(1150, 500, 30, 30, 'goal');
                    break;

                case 10: // Ultimate challenge
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 80, 20, 'platform'));
                    platforms.push(new GameObject(200, 650, 60, 20, 'platform'));
                    platforms.push(new GameObject(400, 550, 60, 20, 'platform'));
                    platforms.push(new GameObject(700, 450, 60, 20, 'platform'));
                    platforms.push(new GameObject(400, 350, 60, 20, 'platform'));
                    platforms.push(new GameObject(100, 250, 60, 20, 'platform'));
                    platforms.push(new GameObject(400, 150, 60, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    lavaBlocks.push(new GameObject(260, 670, 140, 30, 'lava'));
                    lavaBlocks.push(new GameObject(460, 570, 240, 30, 'lava'));
                    lavaBlocks.push(new GameObject(160, 470, 240, 30, 'lava'));
                    lavaBlocks.push(new GameObject(460, 370, 140, 30, 'lava'));
                    lavaBlocks.push(new GameObject(160, 270, 240, 30, 'lava'));
                    goal = new GameObject(420, 100, 30, 30, 'goal');
                    break;

                default:
                    console.error("Level not implemented:", levelNumber);
            }
        }


        // Initialize first level
        createLevel(currentLevel);

        class NeuralNetwork {
            constructor(inputNodes, hiddenNodes, outputNodes) {
                this.input_nodes = inputNodes;
                this.hidden_nodes = hiddenNodes;
                this.output_nodes = outputNodes;
                
                // Initialize weights with slightly higher values to encourage movement
                this.weights_ih = Array(hiddenNodes).fill().map(() => 
                    Array(inputNodes).fill().map(() => this.gaussianRandom(0, 0.5))
                );
                this.weights_hh = Array(hiddenNodes).fill().map(() => 
                    Array(hiddenNodes).fill().map(() => this.gaussianRandom(0, 0.5))
                );
                this.weights_ho = Array(outputNodes).fill().map(() => 
                    Array(hiddenNodes).fill().map(() => this.gaussianRandom(0, 0.5))
                );
                
                // Initialize bias nodes with small positive values
                this.bias_h = Array(hiddenNodes).fill().map(() => this.gaussianRandom(0.1, 0.2));
                this.bias_o = Array(outputNodes).fill().map(() => this.gaussianRandom(0.1, 0.2));
            }

            gaussianRandom(mean = 0, stdev = 1) {
                const u = 1 - Math.random();
                const v = Math.random();
                const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
                return z * stdev + mean;
            }

            // Enhanced activation function using LeakyReLU
            leakyReLU(x) {
                return x > 0 ? x : 0.01 * x;
            }

            predict(inputs) {
                // Normalize inputs
                const normalizedInputs = inputs.map(x => x / Math.max(1, Math.abs(x)));
                
                // First hidden layer
                const hidden1 = this.weights_ih.map((weights, i) =>
                    this.leakyReLU(weights.reduce((sum, weight, j) => 
                        sum + weight * normalizedInputs[j], 0) + this.bias_h[i])
                );
                
                // Second hidden layer
                const hidden2 = this.weights_hh.map((weights, i) =>
                    this.leakyReLU(weights.reduce((sum, weight, j) => 
                        sum + weight * hidden1[j], 0) + this.bias_h[i])
                );
                
                // Output layer with sigmoid activation
                const outputs = this.weights_ho.map(weights =>
                    1 / (1 + Math.exp(-weights.reduce((sum, weight, i) => 
                        sum + weight * hidden2[i], 0) + this.bias_o[this.weights_ho.indexOf(weights)]))
                );

                return outputs;
            }

            clone() {
                const clone = new NeuralNetwork(this.input_nodes, this.hidden_nodes, this.output_nodes);
                clone.weights_ih = this.weights_ih.map(row => [...row]);
                clone.weights_hh = this.weights_hh.map(row => [...row]);
                clone.weights_ho = this.weights_ho.map(row => [...row]);
                clone.bias_h = [...this.bias_h];
                clone.bias_o = [...this.bias_o];
                return clone;
            }

            mutate(rate) {
                const mutateValue = x => {
                    if (Math.random() < rate) {
                        // Use Gaussian mutation for more natural variation
                        return x + this.gaussianRandom(0, 0.5);
                    }
                    return x;
                };
                
                this.weights_ih = this.weights_ih.map(row => row.map(mutateValue));
                this.weights_hh = this.weights_hh.map(row => row.map(mutateValue));
                this.weights_ho = this.weights_ho.map(row => row.map(mutateValue));
                this.bias_h = this.bias_h.map(mutateValue);
                this.bias_o = this.bias_o.map(mutateValue);
            }
        }

        class AIPlayer {
            constructor(brain) {
                // Initialize with game properties
                this.brain = brain || new NeuralNetwork(12, 8, 4);
                this.position = { x: spawnPoint.x, y: spawnPoint.y }; // Use x and y directly
                this.velocity = { x: 0, y: 0 };
                this.width = 30;
                this.height = 30;
                this.fitness = 0;
                this.dead = false;
                this.reachedGoal = false;
                this.isOnGround = false;
                this.canDoubleJump = true;
                this.canDash = true;
                this.isDashing = false;
                this.facingRight = true;
                this.startTime = Date.now();
                this.dashCount = 0;
                this.stateHistory = [];
                this.maxHistoryLength = 10;
                this.timeOnPlatform = 0;
                this.successfulJumps = 0;
                this.distanceTraveled = 0;
                this.previousPosition = { x: spawnPoint.x, y: spawnPoint.y };
            }

            think(gameState) {
                const distanceToGoal = Math.sqrt(
                    Math.pow(this.position.x - goal.position.x, 2) +
                    Math.pow(this.position.y - goal.position.y, 2)
                );
                
                const verticalDistanceToGoal = goal.position.y - this.position.y;
                const horizontalDistanceToGoal = goal.position.x - this.position.x;
                
                const inputs = [
                    this.position.x / CANVAS_WIDTH,
                    this.position.y / CANVAS_HEIGHT,
                    this.velocity.x / MOVE_SPEED,
                    this.velocity.y / JUMP_FORCE,
                    horizontalDistanceToGoal / CANVAS_WIDTH,
                    verticalDistanceToGoal / CANVAS_HEIGHT,
                    this.isOnGround ? 1 : 0,
                    this.canDoubleJump ? 1 : 0,
                    this.canDash ? 1 : 0,
                    this.getNearestPlatformDistance() / CANVAS_WIDTH,
                    this.getNearestLavaDistance() / CANVAS_WIDTH,
                    this.timeOnPlatform / 100
                ];

                // Store state history
                this.stateHistory.push(inputs);
                if (this.stateHistory.length > this.maxHistoryLength) {
                    this.stateHistory.shift();
                }

                const outputs = this.brain.predict(inputs);
                
                // Lower thresholds significantly to encourage more movement
                // and add slight randomness for exploration
                return {
                    left: outputs[0] > 0.3 || Math.random() < 0.1,
                    right: outputs[1] > 0.3 || Math.random() < 0.1,
                    jump: (outputs[2] > 0.4 && this.isOnGround) || Math.random() < 0.05,
                    dash: outputs[3] > 0.6 && this.canDash && Math.random() < 0.1
                };
            }

            getNearestPlatformDistance() {
                return platforms.reduce((nearest, platform) => {
                    const dist = Math.sqrt(
                        Math.pow(this.position.x - platform.position.x, 2) +
                        Math.pow(this.position.y - platform.position.y, 2)
                    );
                    return Math.min(nearest, dist);
                }, Infinity);
            }

            getNearestLavaDistance() {
                return lavaBlocks.reduce((nearest, lava) => {
                    const dist = Math.sqrt(
                        Math.pow(this.position.x - lava.position.x, 2) +
                        Math.pow(this.position.y - lava.position.y, 2)
                    );
                    return Math.min(nearest, dist);
                }, Infinity);
            }

            calculateFitness() {
                const distanceToGoal = Math.sqrt(
                    Math.pow(this.position.x - goal.position.x, 2) +
                    Math.pow(this.position.y - goal.position.y, 2)
                );
                
                const timeTaken = Date.now() - this.startTime;
                const maxTime = 10000; // 10 seconds
                const timeBonus = Math.max(0, 1 - (timeTaken / maxTime));
                
                // Calculate progress towards goal
                const initialDistance = Math.sqrt(
                    Math.pow(spawnPoint.x - goal.position.x, 2) +
                    Math.pow(spawnPoint.y - goal.position.y, 2)
                );
                const progressToGoal = (initialDistance - distanceToGoal) / initialDistance;
                
                // Base fitness calculation
                let fitness = progressToGoal * 0.4 + // Progress towards goal
                            (this.successfulJumps * 0.2) + // Reward for successful jumps
                            (this.timeOnPlatform / 100) * 0.2 + // Reward for platform navigation
                            (this.distanceTraveled / CANVAS_WIDTH) * 0.2; // Reward for exploration
                
                // Additional bonuses
                if (this.reachedGoal) {
                    fitness *= 2;
                    fitness += timeBonus;
                }
                
                // Penalties
                if (this.dead) {
                    fitness *= 0.5;
                }
                
                this.fitness = Math.max(0, fitness);
                return this.fitness;
            }

            update() {
                // Track distance traveled
                const dx = this.position.x - this.previousPosition.x;
                const dy = this.position.y - this.previousPosition.y;
                this.distanceTraveled += Math.sqrt(dx * dx + dy * dy);
                
                // Update previous position
                this.previousPosition = { x: this.position.x, y: this.position.y };
                
                // Track time on platform
                if (this.isOnGround) {
                    this.timeOnPlatform++;
                }
                
                // Track successful jumps (when leaving a platform and landing on another)
                if (!this.isOnGround && this.previouslyOnGround) {
                    this.successfulJumps++;
                }
                this.previouslyOnGround = this.isOnGround;
            }
        }

        class Population {
            constructor(size) {
                this.size = size;
                this.players = Array(size).fill().map(() => {
                    const player = new AIPlayer();
                    // Mutate initial networks more to encourage diversity
                    player.brain.mutate(0.3);
                    return player;
                });
                this.generation = 1;
                this.bestPlayer = null;
                this.bestScore = 0;
                this.stagnantGenerations = 0;
                this.lastBestScore = 0;
                this.speciesList = [];
                this.innovationHistory = [];
                this.gameState = null; // Add gameState property
            }

            update() {
                let allDone = true;
                const currentTime = Date.now();
                
                // Store game state at the beginning of update
                this.gameState = this.getGameState();
                
                this.players.forEach(player => {
                    // Force new generation after 10 seconds
                    if (currentTime - player.startTime > 10000) {
                        player.dead = true;
                        return;
                    }

                    if (!player.dead && !player.reachedGoal) {
                        allDone = false;
                        const decision = player.think(this.gameState);
                        this.applyDecision(player, decision);
                    }
                });

                if (allDone || (currentTime - this.players[0].startTime > 30000)) {
                    return true;
                }

                return false;
            }

            getGameState() {
                return {
                    platforms,
                    lavaBlocks,
                    goal,
                    currentLevel
                };
            }

            calculateAverageFitness() {
                return this.players.reduce((sum, player) => sum + player.fitness, 0) / this.players.length;
            }

            applyDecision(player, decision) {
                // Simulate your game's physics for the AI player
                const prevX = player.position.x;
                if (decision.left) {
                    player.velocity.x = -MOVE_SPEED;
                    player.facingRight = false;
                } else if (decision.right) {
                    player.velocity.x = MOVE_SPEED;
                    player.facingRight = true;
                }

                if (decision.jump) {
                    if (player.isOnGround) {
                        player.velocity.y = -JUMP_FORCE;
                    } else if (player.canDoubleJump) {
                        player.velocity.y = -JUMP_FORCE;
                        player.canDoubleJump = false;
                    }
                }

                if (decision.dash && player.canDash && !player.isDashing) {
                    player.isDashing = true;
                    player.canDash = false;
                    player.velocity.x *= 2;
                    player.dashCount++; // Increment dash counter
                    setTimeout(() => {
                        player.isDashing = false;
                    }, 300);
                }

                // Apply physics
                player.velocity.y += GRAVITY;
                player.position.x += player.velocity.x;
                player.position.y += player.velocity.y;

                // Check collisions
                this.handleCollisions(player);
            }

            handleCollisions(player) {
                // Platform collisions
                player.isOnGround = false;
                
                // Make sure we have valid game state
                if (!this.gameState || !this.gameState.platforms) {
                    console.error('Game state or platforms not defined');
                    return;
                }

                this.gameState.platforms.forEach(platform => {
                    if (this.checkCollision(player, platform)) {
                        const overlapX = Math.min(
                            Math.abs(player.position.x + player.width - platform.position.x),
                            Math.abs(platform.position.x + platform.width - player.position.x)
                        );
                        const overlapY = Math.min(
                            Math.abs(player.position.y + player.height - platform.position.y),
                            Math.abs(platform.position.y + platform.height - player.position.y)
                        );

                        if (overlapX < overlapY) {
                            // Horizontal collision
                            if (player.position.x < platform.position.x) {
                                player.position.x = platform.position.x - player.width;
                            } else {
                                player.position.x = platform.position.x + platform.width;
                            }
                            if (player.isDashing) {
                                player.isDashing = false;
                            }
                        } else {
                            // Vertical collision
                            if (player.position.y < platform.position.y) {
                                player.position.y = platform.position.y - player.height;
                                player.velocity.y = 0;
                                player.isOnGround = true;
                                player.canDoubleJump = true;
                                player.canDash = true;
                            } else {
                                player.position.y = platform.position.y + platform.height;
                                player.velocity.y = 0;
                            }
                        }
                    }
                });

                // Goal collision
                if (this.checkCollision(player, this.gameState.goal)) {
                    player.reachedGoal = true;
                    const playerFitness = player.calculateFitness();
                    if (playerFitness > this.bestScore) {  // Fixed from this.population.bestScore
                        this.bestScore = playerFitness;     // Fixed from this.population.bestScore
                        this.bestPlayer = player;          // Fixed from this.population.bestPlayer
                    }
                }

                // Lava collision
                if (this.gameState.lavaBlocks) {  // Check if lavaBlocks exists
                    this.gameState.lavaBlocks.forEach(lava => {  // Changed from lava to lavaBlocks
                        if (this.checkCollision(player, lava)) {
                            player.dead = true;
                        }
                    });
                }

                // Boundary checks
                if (player.position.x < 0 || 
                    player.position.x + player.width > CANVAS_WIDTH || 
                    player.position.y < 0 || 
                    player.position.y > CANVAS_HEIGHT) {
                    player.dead = true;
                }
            }

            checkCollision(a, b) {
                return a.position.x < b.position.x + b.width &&
                    a.position.x + a.width > b.position.x &&
                    a.position.y < b.position.y + b.height &&
                    a.position.y + a.height > b.position.y;
            }

            naturalSelection() {
                // Calculate fitness for all players
                this.players.forEach(player => player.calculateFitness());
                
                // Sort by fitness
                this.players.sort((a, b) => b.fitness - a.fitness);
                
                // Species separation
                this.speciesList = this.separateIntoSpecies();
                
                // Create new population with species
                const newPlayers = [];
                
                // Elitism - keep best performers from each species
                this.speciesList.forEach(species => {
                    if (species.length > 5) {
                        const clone = new AIPlayer();
                        clone.brain = species[0].brain.clone();
                        newPlayers.push(clone);
                    }
                });
                
                // Fill remaining population
                while (newPlayers.length < this.size) {
                    // Select species based on fitness
                    const species = this.selectSpecies();
                    
                    if (!species || species.length === 0) {
                        continue;
                    }
                    
                    // Tournament selection within species
                    const parent1 = this.tournamentSelect(species);
                    const parent2 = this.tournamentSelect(species);
                    
                    // Create child with crossover
                    const child = this.crossover(parent1, parent2);
                    
                    // Adaptive mutation
                    const mutationRate = Math.min(0.3, 0.1 + (this.stagnantGenerations * 0.02));
                    child.brain.mutate(mutationRate);
                    
                    newPlayers.push(child);
                }
                
                this.players = newPlayers;
                this.generation++;
                
                // Update stagnation counter
                if (this.bestScore > this.lastBestScore) {
                    this.stagnantGenerations = 0;
                    this.lastBestScore = this.bestScore;
                } else {
                    this.stagnantGenerations++;
                }
            }

            selectSpecies() {
                // Calculate total fitness of all species
                const totalFitness = this.speciesList.reduce((sum, species) => 
                    sum + species.reduce((speciesSum, player) => speciesSum + player.fitness, 0), 0);
                
                // If total fitness is 0, return a random species
                if (totalFitness === 0) {
                    return this.speciesList[Math.floor(Math.random() * this.speciesList.length)];
                }
                
                // Otherwise, use fitness proportionate selection
                let random = Math.random() * totalFitness;
                
                for (const species of this.speciesList) {
                    const speciesFitness = species.reduce((sum, player) => sum + player.fitness, 0);
                    random -= speciesFitness;
                    
                    if (random <= 0) {
                        return species;
                    }
                }
                
                // Fallback to last species if we somehow get here
                return this.speciesList[this.speciesList.length - 1];
            }

            separateIntoSpecies() {
                // Implement species separation based on neural network similarity
                // This helps maintain diversity in the population
                const species = [];
                const threshold = 0.3; // Similarity threshold
                
                this.players.forEach(player => {
                    let foundSpecies = false;
                    for (const speciesGroup of species) {
                        if (this.isSimilar(player, speciesGroup[0], threshold)) {
                            speciesGroup.push(player);
                            foundSpecies = true;
                            break;
                        }
                    }
                    if (!foundSpecies) {
                        species.push([player]);
                    }
                });
                
                return species;
            }

            isSimilar(player1, player2, threshold) {
                // Calculate similarity based on neural network weights
                let totalDiff = 0;
                let weightCount = 0;
                
                // Compare hidden layer weights
                player1.brain.weights_ih.forEach((row, i) => {
                    row.forEach((weight, j) => {
                        totalDiff += Math.abs(weight - player2.brain.weights_ih[i][j]);
                        weightCount++;
                    });
                });
                
                // Compare output layer weights
                player1.brain.weights_ho.forEach((row, i) => {
                    row.forEach((weight, j) => {
                        totalDiff += Math.abs(weight - player2.brain.weights_ho[i][j]);
                        weightCount++;
                    });
                });
                
                const avgDiff = totalDiff / weightCount;
                return avgDiff < threshold;
            }

            tournamentSelect(species) {
                const tournamentSize = Math.min(5, species.length);
                const tournament = Array(tournamentSize).fill()
                    .map(() => species[Math.floor(Math.random() * species.length)]);
                return tournament.reduce((best, current) => 
                    current.fitness > best.fitness ? current : best
                );
            }

            crossover(parent1, parent2) {
                const child = new AIPlayer();
                
                // Weighted average crossover
                for (let i = 0; i < parent1.brain.weights_ih.length; i++) {
                    for (let j = 0; j < parent1.brain.weights_ih[i].length; j++) {
                        const weight = Math.random() < 0.5 ? 
                            parent1.brain.weights_ih[i][j] : 
                            parent2.brain.weights_ih[i][j];
                        child.brain.weights_ih[i][j] = weight;
                    }
                }
                
                for (let i = 0; i < parent1.brain.weights_ho.length; i++) {
                    for (let j = 0; j < parent1.brain.weights_ho[i].length; j++) {
                        const weight = Math.random() < 0.5 ? 
                            parent1.brain.weights_ho[i][j] : 
                            parent2.brain.weights_ho[i][j];
                        child.brain.weights_ho[i][j] = weight;
                    }
                }
                
                return child;
            }
        }

        // Training system setup
        const trainingSystem = new Population(500);

        // Main training loop
        function trainAI() {
            if (trainingSystem.update()) {
                console.log(`Generation ${trainingSystem.generation} complete`);
                console.log(`Best fitness: ${trainingSystem.bestScore}`);
                
                if (trainingSystem.bestScore > 0.9) {
                    console.log("Level completed! Moving to next level...");
                    currentLevel++;
                    createLevel(currentLevel);
                }
                
                trainingSystem.naturalSelection();
            }
            
            requestAnimationFrame(trainAI);
        }

        // Start training
        trainAI();

        // Training System class
        class TrainingSystem {
            constructor(populationSize = 50) {
                this.population = new Population(populationSize);
                this.currentLevel = 1;
                this.gameState = this.createGameState(this.currentLevel);
                this.generationStats = [];
                this.levelStartTime = Date.now();
                this.highestLevelReached = 1;
                this.playerLevels = new Map();
                this.currentBestPlayer = null;
                this.generationTimeLimit = 10000; // 10 seconds per generation
                this.lastUpdateTime = Date.now();
                this.minUpdateInterval = 16; // ~60 FPS
                
                this.population.players.forEach(player => {
                    this.playerLevels.set(player, 1);
                });
            }

            createGameState(level) {
                createLevel(level);
                return {
                    platforms: platforms,
                    lava: lavaBlocks,
                    goal: goal,
                    nearestPlatform: this.findNearestPlatform({ x: spawnPoint.x, y: spawnPoint.y }, platforms)
                };
            }

            getCurrentBestPlayer() {
                if (!this.currentBestPlayer || this.currentBestPlayer.dead) {
                    // Find the player with the best current performance
                    let bestFitness = -Infinity;
                    let bestPlayer = null;

                    this.population.players.forEach(player => {
                        if (!player.dead) {
                            const currentFitness = this.calculatePlayerFitness(player);
                            if (currentFitness > bestFitness) {
                                bestFitness = currentFitness;
                                bestPlayer = player;
                            }
                        }
                    });

                    this.currentBestPlayer = bestPlayer || this.population.players[0];
                }
                return this.currentBestPlayer;
            }

            calculatePlayerFitness(player) {
                const currentLevel = this.playerLevels.get(player);
                let totalFitness = 0;
                
                // Calculate fitness for each level the player has attempted
                for (let level = 1; level <= currentLevel; level++) {
                    const levelState = this.getGameStateForLevel(level);
                    const goal = levelState.goal;
                    
                    // Distance component
                    const distanceToGoal = Math.sqrt(
                        Math.pow(player.position.x - goal.position.x, 2) +
                        Math.pow(player.position.y - goal.position.y, 2)
                    );
                    const maxPossibleDistance = Math.sqrt(
                        Math.pow(CANVAS_WIDTH, 2) + Math.pow(CANVAS_HEIGHT, 2)
                    );
                    const distanceScore = 1 - (distanceToGoal / maxPossibleDistance);
                    
                    // Speed component
                    const completionTime = player.levelCompletionTimes?.[level] || (Date.now() - player.startTime);
                    const timeScore = Math.max(0, 1 - (completionTime / this.generationTimeLimit));
                    
                    // Level completion bonus
                    const completionBonus = player.levelCompletionTimes?.[level] ? 1 : 0;
                    
                    // Combine scores with weights
                    const levelFitness = (
                        distanceScore * 0.4 +      // 40% weight for distance
                        timeScore * 0.3 +          // 30% weight for speed
                        completionBonus * 0.3      // 30% weight for completion
                    );
                    
                    // Add progressive level bonus
                    const levelBonus = Math.pow(2, level - 1);
                    totalFitness += levelFitness * levelBonus;
                }
                
                return totalFitness;
            }

            handleCollisions(player) {
                // Platform collisions
                player.isOnGround = false;
                
                const currentGameState = this.getGameStateForLevel(this.playerLevels.get(player));
                
                currentGameState.platforms.forEach(platform => {
                    if (this.checkCollision(player, platform)) {
                        const overlapX = Math.min(
                            Math.abs(player.position.x + player.width - platform.position.x),
                            Math.abs(platform.position.x + platform.width - player.position.x)
                        );
                        const overlapY = Math.min(
                            Math.abs(player.position.y + player.height - platform.position.y),
                            Math.abs(platform.position.y + platform.height - player.position.y)
                        );

                        if (overlapX < overlapY) {
                            // Horizontal collision
                            if (player.position.x < platform.position.x) {
                                player.position.x = platform.position.x - player.width;
                            } else {
                                player.position.x = platform.position.x + platform.width;
                            }
                            if (player.isDashing) {
                                player.isDashing = false;
                            }
                        } else {
                            // Vertical collision
                            if (player.position.y < platform.position.y) {
                                player.position.y = platform.position.y - player.height;
                                player.velocity.y = 0;
                                player.isOnGround = true;
                                player.canDoubleJump = true;
                                player.canDash = true;
                            } else {
                                player.position.y = platform.position.y + platform.height;
                                player.velocity.y = 0;
                            }
                        }
                    }
                });

                if (this.checkCollision(player, currentGameState.goal)) {
                    const currentLevel = this.playerLevels.get(player);
                    this.playerLevels.set(player, currentLevel + 1);
                    player.reachedGoal = true;
                    
                    // Instead of killing the player, reset them at the next level
                    const nextLevelState = this.getGameStateForLevel(currentLevel + 1);
                    player.position = { x: spawnPoint.x, y: spawnPoint.y };
                    player.velocity = { x: 0, y: 0 };
                    player.reachedGoal = false;
                    player.isOnGround = false;
                    player.canDoubleJump = true;
                    player.canDash = true;
                    player.isDashing = false;
                    
                    // Update highest level reached if necessary
                    this.highestLevelReached = Math.max(this.highestLevelReached, currentLevel + 1);
                    
                    // Store the completion time for the level
                    if (!player.levelCompletionTimes) player.levelCompletionTimes = {};
                    player.levelCompletionTimes[currentLevel] = Date.now() - player.startTime;
                }

                // Lava collision
                currentGameState.lava.forEach(lava => {
                    if (this.checkCollision(player, lava)) {
                        player.dead = true;
                    }
                });

                // Boundary checks
                if (player.position.x < 0 || 
                    player.position.x + player.width > CANVAS_WIDTH || 
                    player.position.y < 0 || 
                    player.position.y > CANVAS_HEIGHT) {
                    player.dead = true;
                }
            }

            checkCollision(a, b) {
                return a.position.x < b.position.x + b.width &&
                    a.position.x + a.width > b.position.x &&
                    a.position.y < b.position.y + b.height &&
                    a.position.y + a.height > b.position.y;
            }

            // Add the applyDecision method
            applyDecision(player, decision) {
                const prevX = player.position.x;
                if (decision.left) {
                    player.velocity.x = -MOVE_SPEED;
                    player.facingRight = false;
                } else if (decision.right) {
                    player.velocity.x = MOVE_SPEED;
                    player.facingRight = true;
                }

                if (decision.jump) {
                    if (player.isOnGround) {
                        player.velocity.y = -JUMP_FORCE;
                    } else if (player.canDoubleJump) {
                        player.velocity.y = -JUMP_FORCE;
                        player.canDoubleJump = false;
                    }
                }

                if (decision.dash && player.canDash && !player.isDashing) {
                    player.isDashing = true;
                    player.canDash = false;
                    player.velocity.x *= 2;
                    player.dashCount++;
                    setTimeout(() => {
                        player.isDashing = false;
                    }, 300);
                }

                // Apply physics
                player.velocity.y += GRAVITY;
                player.position.x += player.velocity.x;
                player.position.y += player.velocity.y;

                // Check collisions
                this.handleCollisions(player);
            }

            findNearestPlatform(position, platforms) {
                return platforms.reduce((nearest, platform) => {
                    const distance = Math.sqrt(
                        Math.pow(platform.x + platform.width/2 - position.x, 2) +
                        Math.pow(platform.y - position.y, 2)
                    );
                    return distance < nearest.distance ? {
                        x: platform.x + platform.width/2,
                        y: platform.y,
                        distance
                    } : nearest;
                }, { x: 0, y: 0, distance: Infinity });
            }

            getGameStateForLevel(level) {
                // Create game state for specific level
                return this.createGameState(level);
            }

            update() {
                const currentTime = Date.now();
                const deltaTime = currentTime - this.lastUpdateTime;

                // Enforce minimum update interval
                if (deltaTime < this.minUpdateInterval) {
                    return null;
                }

                this.lastUpdateTime = currentTime;
                let allDead = true;
                let bestCurrentFitness = -Infinity;

                // Update each player individually
                this.population.players.forEach(player => {
                    if (!player.dead && !player.reachedGoal) {
                        allDead = false;
                        
                        // Check time limit
                        if (currentTime - player.startTime > this.generationTimeLimit) {
                            player.dead = true;
                            return;
                        }

                        const decision = player.think(this.getGameStateForLevel(this.playerLevels.get(player)));
                        this.applyDecision(player, decision);
                        
                        // Update current best player
                        const fitness = this.calculatePlayerFitness(player);
                        if (fitness > bestCurrentFitness) {
                            bestCurrentFitness = fitness;
                            this.currentBestPlayer = player;
                        }
                    }
                });

                // Check if generation should end
                if (allDead || (currentTime - this.levelStartTime > this.generationTimeLimit)) {
                    const stats = this.calculateGenerationStats();
                    this.generationStats.push(stats);
                    
                    // Store best brain before reset
                    const bestBrain = this.population.bestPlayer ? this.population.bestPlayer.brain.clone() : null;
                    
                    // Perform natural selection
                    this.population.naturalSelection();
                    
                    // Reset all players but preserve progress
                    this.population.players.forEach(player => {
                        this.resetPlayer(player);
                        this.playerLevels.set(player, 1);
                        
                        if (bestBrain) {
                            player.brain = bestBrain.clone();
                            player.brain.mutate(0.1);
                        }
                    });

                    this.currentBestPlayer = null;
                    this.levelStartTime = Date.now();
                    
                    return stats;
                }

                return null;
            }

            calculateGenerationStats() {
                // Calculate fitness with level progression bonus
                const players = this.population.players;
                players.forEach(player => {
                    const playerLevel = this.playerLevels.get(player);
                    const levelBonus = Math.pow(2, playerLevel - 1); // Exponential bonus for higher levels
                    
                    // Base fitness calculation
                    let baseFitness = player.calculateFitness();
                    
                    // Distance to goal bonus (normalized)
                    const distanceToGoal = Math.sqrt(
                        Math.pow(player.position.x - goal.position.x, 2) +
                        Math.pow(player.position.y - goal.position.y, 2)
                    );
                    const maxPossibleDistance = Math.sqrt(
                        Math.pow(CANVAS_WIDTH, 2) + Math.pow(CANVAS_HEIGHT, 2)
                    );
                    const distanceBonus = 1 - (distanceToGoal / maxPossibleDistance);
                    
                    // Survival time bonus
                    const survivalTimeBonus = Math.min(
                        (Date.now() - player.startTime) / 10000, 
                        1
                    );
                    
                    // Movement efficiency bonus
                    const efficiencyBonus = player.distanceTraveled / 
                        (Math.abs(goal.position.x - spawnPoint.x) * 1.5);
                    
                    // Combine all factors
                    player.fitness = (
                        baseFitness * 0.4 +
                        distanceBonus * 0.3 +
                        survivalTimeBonus * 0.2 +
                        efficiencyBonus * 0.1
                    ) * levelBonus;
                });

                return {
                    generation: this.population.generation,
                    bestFitness: Math.max(...players.map(p => p.fitness)),
                    averageFitness: players.reduce((sum, p) => sum + p.fitness, 0) / players.length,
                    currentLevel: Math.max(...Array.from(this.playerLevels.values())),
                    highestLevelReached: this.highestLevelReached,
                    goalReached: players.some(p => p.reachedGoal)
                };
            }

            resetPlayerForNewLevel(player) {
                player.position = { x: spawnPoint.x, y: spawnPoint.y };
                player.velocity = { x: 0, y: 0 };
                player.dead = false;
                player.reachedGoal = false;
                player.isOnGround = false;
                player.canDoubleJump = true;
                player.canDash = true;
                player.isDashing = false;
                // Don't reset start time here to maintain level time limit
            }

            resetPlayer(player) {
                player.position = { x: spawnPoint.x, y: spawnPoint.y };
                player.velocity = { x: 0, y: 0 };
                player.dead = false;
                player.reachedGoal = false;
                player.startTime = Date.now();
                player.dashCount = 0;
                player.isOnGround = false;
                player.canDoubleJump = true;
                player.canDash = true;
                player.isDashing = false;
            }

            getStats() {
                return this.generationStats;
            }

            getBestPlayer() {
                return this.population.bestPlayer;
            }

            reset() {
                this.currentLevel = 1;
                this.gameState = this.createGameState(this.currentLevel);
                this.population = new Population(this.population.players.length);
                this.generationStats = [];
                this.highestLevelReached = 1;
            }
        }

        const GameCanvas = ({ gameState, trainingSystem }) => {
            const canvasRef = React.useRef(null);
            const animationFrameRef = React.useRef(null);

            const draw = React.useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas || !trainingSystem) return;
                
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw platforms
                ctx.fillStyle = '#333';
                if (trainingSystem.gameState?.platforms) {
                    trainingSystem.gameState.platforms.forEach(platform => {
                        if (platform?.position?.x != null && platform?.position?.y != null) {
                            ctx.fillRect(
                                platform.position.x,
                                platform.position.y,
                                platform.width,
                                platform.height
                            );
                        }
                    });
                }

                // Draw lava
                ctx.fillStyle = '#ff4444';
                if (trainingSystem.gameState?.lava) {
                    trainingSystem.gameState.lava.forEach(lava => {
                        if (lava?.position?.x != null && lava?.position?.y != null) {
                            ctx.fillRect(
                                lava.position.x,
                                lava.position.y,
                                lava.width,
                                lava.height
                            );
                        }
                    });
                }

                // Draw goal
                if (trainingSystem.gameState?.goal?.position?.x != null && trainingSystem.gameState?.goal?.position?.y != null) {
                    ctx.fillStyle = '#44ff44';
                    ctx.fillRect(
                        trainingSystem.gameState.goal.position.x,
                        trainingSystem.gameState.goal.position.y,
                        trainingSystem.gameState.goal.width,
                        trainingSystem.gameState.goal.height
                    );
                }

                // Draw all players with transparency
                if (trainingSystem.population?.players) {
                    trainingSystem.population.players.forEach(player => {
                        if (!player.dead && player.position?.x != null && player.position?.y != null) {
                            ctx.fillStyle = player.reachedGoal ? '#44ff44' : '#4444ff';
                            ctx.globalAlpha = 0.3;
                            ctx.fillRect(
                                player.position.x,
                                player.position.y,
                                player.width || 20,
                                player.height || 20
                            );
                        }
                    });
                }

                // Draw best player with full opacity
                const bestPlayer = trainingSystem.getCurrentBestPlayer();
                if (bestPlayer && !bestPlayer.dead && bestPlayer.position?.x != null && bestPlayer.position?.y != null) {
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = bestPlayer.reachedGoal ? '#44ff44' : '#ff8800';
                    ctx.fillRect(
                        bestPlayer.position.x,
                        bestPlayer.position.y,
                        bestPlayer.width || 20,
                        bestPlayer.height || 20
                    );
                }

                ctx.globalAlpha = 1.0;
            }, [trainingSystem]);

            React.useEffect(() => {
                const animate = () => {
                    draw();
                    animationFrameRef.current = requestAnimationFrame(animate);
                };
                
                animate();
                
                return () => {
                    if (animationFrameRef.current) {
                        cancelAnimationFrame(animationFrameRef.current);
                    }
                };
            }, [draw]);

            return (
                <canvas
                    ref={canvasRef}
                    width={CANVAS_WIDTH}
                    height={CANVAS_HEIGHT}
                    className="border border-gray-300 bg-white"
                />
            );
        };

        const AITrainer = () => {
            const [generation, setGeneration] = React.useState(1);
            const [isTraining, setIsTraining] = React.useState(false);
            const [speed, setSpeed] = React.useState(1);
            const [stats, setStats] = React.useState({
                averageFitness: 0,
                bestFitness: 0,
                goalReached: false,
                generation: 1,
                currentLevel: 1,
                highestLevelReached: 1
            });
            const [allTimeStats, setAllTimeStats] = React.useState([]);
            const trainingSystemRef = React.useRef(null);

            React.useEffect(() => {
                if (!trainingSystemRef.current) {
                    trainingSystemRef.current = new TrainingSystem(50);
                }
            }, []);

            const updateSimulation = React.useCallback(() => {
                if (!isTraining || !trainingSystemRef.current) return;

                for (let i = 0; i < speed; i++) {
                    const newStats = trainingSystemRef.current.update();
                    if (newStats) {
                        setStats(newStats);
                        setAllTimeStats(prev => [...prev, newStats]);
                        setGeneration(newStats.generation);
                    }
                }
                
                requestAnimationFrame(updateSimulation);
            }, [isTraining, speed]);

            React.useEffect(() => {
                let animationFrame;
                if (isTraining) {
                    animationFrame = requestAnimationFrame(updateSimulation);
                }
                return () => {
                    if (animationFrame) {
                        cancelAnimationFrame(animationFrame);
                    }
                };
            }, [isTraining, updateSimulation]);

            return (
                <div className="flex flex-col gap-8 p-4">
                    <Card className="w-full max-w-7xl mx-auto">
                        <CardHeader>
                            <CardTitle>
                                AI Training Progress - Generation {generation}
                                <span className="ml-4 text-gray-600">
                                    Current Level: {stats.currentLevel} | Best Level: {stats.highestLevelReached}
                                </span>
                            </CardTitle>
                        </CardHeader>
                        <CardContent>
                            <div className="flex flex-col gap-4">
                                <div className="flex gap-4 items-center">
                                    <button 
                                        className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                                        onClick={() => setIsTraining(!isTraining)}
                                    >
                                        {isTraining ? "Pause" : "Play"}
                                    </button>
                                    <button 
                                        className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
                                        onClick={() => setSpeed(s => Math.min(s * 2, 16))}
                                    >
                                        Speed Up
                                    </button>
                                    <span className="text-lg">Speed: {speed}x</span>
                                </div>

                                <div className="grid grid-cols-4 gap-4">
                                    <div className="bg-gray-100 p-4 rounded">
                                        <div className="text-lg">Average Fitness</div>
                                        <div className="text-2xl">{stats.averageFitness.toFixed(4)}</div>
                                    </div>
                                    <div className="bg-gray-100 p-4 rounded">
                                        <div className="text-lg">Best Fitness</div>
                                        <div className="text-2xl">{stats.bestFitness.toFixed(4)}</div>
                                    </div>
                                    <div className="bg-gray-100 p-4 rounded">
                                        <div className="text-lg">Goals Reached</div>
                                        <div className="text-2xl">{allTimeStats.filter(s => s.goalReached).length}</div>
                                    </div>
                                    <div className="bg-gray-100 p-4 rounded">
                                        <div className="text-lg">Current Level</div>
                                        <div className="text-2xl">{stats.currentLevel}</div>
                                    </div>
                                </div>

                                <div className="w-full h-[800px] bg-gray-50 rounded overflow-hidden flex items-center justify-center">
                                    {trainingSystemRef.current && (
                                        <GameCanvas 
                                            trainingSystem={trainingSystemRef.current}
                                        />
                                    )}
                                </div>

                                <div className="h-[300px] w-full">
                                    <ResponsiveContainer>
                                        <LineChart data={allTimeStats}>
                                            <CartesianGrid strokeDasharray="3 3" />
                                            <XAxis dataKey="generation" />
                                            <YAxis />
                                            <Tooltip />
                                            <Legend />
                                            <Line type="monotone" dataKey="averageFitness" stroke="#8884d8" />
                                            <Line type="monotone" dataKey="bestFitness" stroke="#82ca9d" />
                                        </LineChart>
                                    </ResponsiveContainer>
                                </div>
                            </div>
                        </CardContent>
                    </Card>
                </div>
            );
        };

        const Card = ({ children, className = "" }) => (
            <div className={`bg-white rounded-lg shadow ${className}`}>{children}</div>
        );

        const CardHeader = ({ children }) => (
            <div className="p-6 border-b">{children}</div>
        );

        const CardTitle = ({ children }) => (
            <h2 className="text-2xl font-bold">{children}</h2>
        );

        const CardContent = ({ children }) => (
            <div className="p-6">{children}</div>
        );

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<AITrainer />);
    </script>
</body>
</html>