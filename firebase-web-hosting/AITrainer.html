<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Training Visualization</title>
    
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prop-types/15.8.1/prop-types.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.10.3/Recharts.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 p-8">
    <div id="root"></div>

    <script type="text/babel">
        const {
            LineChart,
            Line,
            XAxis,
            YAxis,
            CartesianGrid,
            Tooltip,
            Legend,
            ResponsiveContainer
        } = window.Recharts;

        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 800;
        const MOVE_SPEED = 7;
        const JUMP_FORCE = 13;
        const GRAVITY = 0.7;

        let currentLevelReached = 1;
        const DASH_REWARD = 0.3; // Reward multiplier for dashing

        let currentLevel = 1;

        let spawnPoint = { x: 100, y: 700 };
        const platforms = [
            { position: { x: 0, y: 750 }, width: CANVAS_WIDTH, height: 20 }
        ];
        const lavaBlocks = [];
        let goal = {
            position: { x: 1150, y: 700 },
            width: 30,
            height: 30
        };


        class GameObject {
            constructor(x, y, width, height, type) {
                this.position = { x, y };
                this.width = width;
                this.height = height;
                this.type = type; // For example: 'platform', 'goal', or 'lava'
            }
        }

        function createLevel(levelNumber) {
            // Clear existing platforms and lava blocks
            platforms.length = 0;
            lavaBlocks.length = 0;

            switch(levelNumber) {
                case 1: // Basic movement tutorial
                    spawnPoint = { x: 100, y: 700 };
                    platforms.push(new GameObject(0, 750, 1200, 20, 'platform'));
                    goal = new GameObject(1150, 700, 30, 30, 'goal');
                    break;

                case 2: // Jump tutorial
                    spawnPoint = { x: 100, y: 700 };
                    platforms.push(new GameObject(0, 750, 300, 20, 'platform'));
                    platforms.push(new GameObject(400, 700, 200, 20, 'platform'));
                    platforms.push(new GameObject(700, 600, 200, 20, 'platform'));
                    goal = new GameObject(800, 550, 30, 30, 'goal');
                    break;

                case 3: // Double jump tutorial
                    spawnPoint = { x: 100, y: 700 };
                    platforms.push(new GameObject(0, 750, 300, 20, 'platform'));
                    platforms.push(new GameObject(700, 600, 200, 20, 'platform'));
                    goal = new GameObject(800, 550, 30, 30, 'goal');
                    break;

                case 4: // Dash tutorial
                    spawnPoint = { x: 100, y: 700 };
                    platforms.push(new GameObject(0, 750, 300, 20, 'platform'));
                    platforms.push(new GameObject(900, 750, 300, 20, 'platform'));
                    lavaBlocks.push(new GameObject(300, 770, 600, 30, 'lava'));
                    goal = new GameObject(1000, 700, 30, 30, 'goal');
                    break;

                case 5: // Combining jumps and dashes
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 200, 20, 'platform'));
                    platforms.push(new GameObject(400, 650, 150, 20, 'platform'));
                    platforms.push(new GameObject(800, 550, 150, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    goal = new GameObject(850, 500, 30, 30, 'goal');
                    break;

                case 6: // Precision jumping
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 150, 20, 'platform'));
                    platforms.push(new GameObject(300, 650, 100, 20, 'platform'));
                    platforms.push(new GameObject(600, 550, 100, 20, 'platform'));
                    platforms.push(new GameObject(300, 450, 100, 20, 'platform'));
                    platforms.push(new GameObject(600, 350, 100, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    goal = new GameObject(650, 300, 30, 30, 'goal');
                    break;

                case 7: // Speed and timing
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 150, 20, 'platform'));
                    platforms.push(new GameObject(400, 750, 100, 20, 'platform'));
                    platforms.push(new GameObject(800, 650, 100, 20, 'platform'));
                    platforms.push(new GameObject(400, 550, 100, 20, 'platform'));
                    platforms.push(new GameObject(0, 450, 100, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    lavaBlocks.push(new GameObject(500, 670, 300, 30, 'lava'));
                    lavaBlocks.push(new GameObject(100, 570, 300, 30, 'lava'));
                    goal = new GameObject(50, 400, 30, 30, 'goal');
                    break;

                case 8: // Aerial control
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 100, 20, 'platform'));
                    platforms.push(new GameObject(200, 650, 80, 20, 'platform'));
                    platforms.push(new GameObject(400, 550, 80, 20, 'platform'));
                    platforms.push(new GameObject(600, 450, 80, 20, 'platform'));
                    platforms.push(new GameObject(800, 350, 80, 20, 'platform'));
                    platforms.push(new GameObject(1000, 250, 100, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    goal = new GameObject(1050, 200, 30, 30, 'goal');
                    break;

                case 9: // Complex movement
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 150, 20, 'platform'));
                    platforms.push(new GameObject(300, 650, 80, 20, 'platform'));
                    platforms.push(new GameObject(600, 750, 80, 20, 'platform'));
                    platforms.push(new GameObject(900, 650, 80, 20, 'platform'));
                    platforms.push(new GameObject(1100, 550, 100, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    lavaBlocks.push(new GameObject(380, 670, 220, 30, 'lava'));
                    lavaBlocks.push(new GameObject(680, 670, 220, 30, 'lava'));
                    goal = new GameObject(1150, 500, 30, 30, 'goal');
                    break;

                case 10: // Ultimate challenge
                    spawnPoint = { x: 50, y: 700 };
                    platforms.push(new GameObject(0, 750, 80, 20, 'platform'));
                    platforms.push(new GameObject(200, 650, 60, 20, 'platform'));
                    platforms.push(new GameObject(400, 550, 60, 20, 'platform'));
                    platforms.push(new GameObject(700, 450, 60, 20, 'platform'));
                    platforms.push(new GameObject(400, 350, 60, 20, 'platform'));
                    platforms.push(new GameObject(100, 250, 60, 20, 'platform'));
                    platforms.push(new GameObject(400, 150, 60, 20, 'platform'));
                    lavaBlocks.push(new GameObject(0, 770, 1200, 30, 'lava'));
                    lavaBlocks.push(new GameObject(260, 670, 140, 30, 'lava'));
                    lavaBlocks.push(new GameObject(460, 570, 240, 30, 'lava'));
                    lavaBlocks.push(new GameObject(160, 470, 240, 30, 'lava'));
                    lavaBlocks.push(new GameObject(460, 370, 140, 30, 'lava'));
                    lavaBlocks.push(new GameObject(160, 270, 240, 30, 'lava'));
                    goal = new GameObject(420, 100, 30, 30, 'goal');
                    break;

                default:
                    console.error("Level not implemented:", levelNumber);
            }
        }


        // Initialize first level
        createLevel(currentLevel);

        class NeuralNetwork {
            constructor(inputNodes, hiddenNodes, outputNodes) {
                this.input_nodes = inputNodes;
                this.hidden_nodes = hiddenNodes;
                this.output_nodes = outputNodes;
                
                // Add multiple hidden layers for more complex behavior learning
                this.weights_ih = Array(hiddenNodes).fill().map(() => 
                    Array(inputNodes).fill().map(() => this.gaussianRandom())
                );
                this.weights_hh = Array(hiddenNodes).fill().map(() => 
                    Array(hiddenNodes).fill().map(() => this.gaussianRandom())
                );
                this.weights_ho = Array(outputNodes).fill().map(() => 
                    Array(hiddenNodes).fill().map(() => this.gaussianRandom())
                );
                
                // Add bias nodes
                this.bias_h = Array(hiddenNodes).fill().map(() => this.gaussianRandom());
                this.bias_o = Array(outputNodes).fill().map(() => this.gaussianRandom());
            }

            gaussianRandom(mean = 0, stdev = 1) {
                const u = 1 - Math.random();
                const v = Math.random();
                const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
                return z * stdev + mean;
            }

            // Enhanced activation function using LeakyReLU
            leakyReLU(x) {
                return x > 0 ? x : 0.01 * x;
            }

            predict(inputs) {
                // Normalize inputs
                const normalizedInputs = inputs.map(x => x / Math.max(1, Math.abs(x)));
                
                // First hidden layer
                const hidden1 = this.weights_ih.map((weights, i) =>
                    this.leakyReLU(weights.reduce((sum, weight, j) => 
                        sum + weight * normalizedInputs[j], 0) + this.bias_h[i])
                );
                
                // Second hidden layer
                const hidden2 = this.weights_hh.map((weights, i) =>
                    this.leakyReLU(weights.reduce((sum, weight, j) => 
                        sum + weight * hidden1[j], 0) + this.bias_h[i])
                );
                
                // Output layer with sigmoid activation
                const outputs = this.weights_ho.map(weights =>
                    1 / (1 + Math.exp(-weights.reduce((sum, weight, i) => 
                        sum + weight * hidden2[i], 0) + this.bias_o[this.weights_ho.indexOf(weights)]))
                );

                return outputs;
            }

            clone() {
                const clone = new NeuralNetwork(this.input_nodes, this.hidden_nodes, this.output_nodes);
                clone.weights_ih = this.weights_ih.map(row => [...row]);
                clone.weights_hh = this.weights_hh.map(row => [...row]);
                clone.weights_ho = this.weights_ho.map(row => [...row]);
                clone.bias_h = [...this.bias_h];
                clone.bias_o = [...this.bias_o];
                return clone;
            }

            mutate(rate) {
                const mutateValue = x => {
                    if (Math.random() < rate) {
                        // Use Gaussian mutation for more natural variation
                        return x + this.gaussianRandom(0, 0.5);
                    }
                    return x;
                };
                
                this.weights_ih = this.weights_ih.map(row => row.map(mutateValue));
                this.weights_hh = this.weights_hh.map(row => row.map(mutateValue));
                this.weights_ho = this.weights_ho.map(row => row.map(mutateValue));
                this.bias_h = this.bias_h.map(mutateValue);
                this.bias_o = this.bias_o.map(mutateValue);
            }
        }

        class AIPlayer {
            constructor(brain) {
                // Initialize with game properties
                this.brain = brain || new NeuralNetwork(12, 8, 4);
                this.position = { x: spawnPoint.x, y: spawnPoint.y }; // Use x and y directly
                this.velocity = { x: 0, y: 0 };
                this.width = 30;
                this.height = 30;
                this.fitness = 0;
                this.dead = false;
                this.reachedGoal = false;
                this.isOnGround = false;
                this.canDoubleJump = true;
                this.canDash = true;
                this.isDashing = false;
                this.facingRight = true;
                this.startTime = Date.now();
                this.dashCount = 0;
                this.stateHistory = [];
                this.maxHistoryLength = 10;
                this.timeOnPlatform = 0;
                this.successfulJumps = 0;
                this.distanceTraveled = 0;
                this.previousPosition = { x: spawnPoint.x, y: spawnPoint.y };
            }

            think(gameState) {
                // Calculate additional inputs
                const distanceToGoal = Math.sqrt(
                    Math.pow(this.position.x - goal.position.x, 2) +
                    Math.pow(this.position.y - goal.position.y, 2)
                );
                
                const verticalDistanceToGoal = goal.position.y - this.position.y;
                const horizontalDistanceToGoal = goal.position.x - this.position.x;
                
                const inputs = [
                    this.position.x / CANVAS_WIDTH,
                    this.position.y / CANVAS_HEIGHT,
                    this.velocity.x / MOVE_SPEED,
                    this.velocity.y / JUMP_FORCE,
                    horizontalDistanceToGoal / CANVAS_WIDTH,
                    verticalDistanceToGoal / CANVAS_HEIGHT,
                    this.isOnGround ? 1 : 0,
                    this.canDoubleJump ? 1 : 0,
                    this.canDash ? 1 : 0,
                    this.getNearestPlatformDistance() / CANVAS_WIDTH,
                    this.getNearestLavaDistance() / CANVAS_WIDTH,
                    this.timeOnPlatform / 100, // Normalized time on platform
                    this.successfulJumps / 10, // Normalized jump success
                    distanceToGoal / Math.sqrt(Math.pow(CANVAS_WIDTH, 2) + Math.pow(CANVAS_HEIGHT, 2)),
                    Math.min(1, this.distanceTraveled / CANVAS_WIDTH) // Normalized distance traveled
                ];

                // Store state history
                this.stateHistory.push(inputs);
                if (this.stateHistory.length > this.maxHistoryLength) {
                    this.stateHistory.shift();
                }

                const outputs = this.brain.predict(inputs);
                return {
                    left: outputs[0] > 0.5,
                    right: outputs[1] > 0.5,
                    jump: outputs[2] > 0.5,
                    dash: outputs[3] > 0.5
                };
            }

            getNearestPlatformDistance() {
                return platforms.reduce((nearest, platform) => {
                    const dist = Math.sqrt(
                        Math.pow(this.position.x - platform.position.x, 2) +
                        Math.pow(this.position.y - platform.position.y, 2)
                    );
                    return Math.min(nearest, dist);
                }, Infinity);
            }

            getNearestLavaDistance() {
                return lavaBlocks.reduce((nearest, lava) => {
                    const dist = Math.sqrt(
                        Math.pow(this.position.x - lava.position.x, 2) +
                        Math.pow(this.position.y - lava.position.y, 2)
                    );
                    return Math.min(nearest, dist);
                }, Infinity);
            }

            calculateFitness() {
                const distanceToGoal = Math.sqrt(
                    Math.pow(this.position.x - goal.position.x, 2) +
                    Math.pow(this.position.y - goal.position.y, 2)
                );
                
                const timeTaken = Date.now() - this.startTime;
                const maxTime = 10000; // 10 seconds
                const timeBonus = Math.max(0, 1 - (timeTaken / maxTime));
                
                // Calculate progress towards goal
                const initialDistance = Math.sqrt(
                    Math.pow(spawnPoint.x - goal.position.x, 2) +
                    Math.pow(spawnPoint.y - goal.position.y, 2)
                );
                const progressToGoal = (initialDistance - distanceToGoal) / initialDistance;
                
                // Base fitness calculation
                let fitness = progressToGoal * 0.4 + // Progress towards goal
                            (this.successfulJumps * 0.2) + // Reward for successful jumps
                            (this.timeOnPlatform / 100) * 0.2 + // Reward for platform navigation
                            (this.distanceTraveled / CANVAS_WIDTH) * 0.2; // Reward for exploration
                
                // Additional bonuses
                if (this.reachedGoal) {
                    fitness *= 2;
                    fitness += timeBonus;
                }
                
                // Penalties
                if (this.dead) {
                    fitness *= 0.5;
                }
                
                this.fitness = Math.max(0, fitness);
                return this.fitness;
            }

            update() {
                // Track distance traveled
                const dx = this.position.x - this.previousPosition.x;
                const dy = this.position.y - this.previousPosition.y;
                this.distanceTraveled += Math.sqrt(dx * dx + dy * dy);
                
                // Update previous position
                this.previousPosition = { x: this.position.x, y: this.position.y };
                
                // Track time on platform
                if (this.isOnGround) {
                    this.timeOnPlatform++;
                }
                
                // Track successful jumps (when leaving a platform and landing on another)
                if (!this.isOnGround && this.previouslyOnGround) {
                    this.successfulJumps++;
                }
                this.previouslyOnGround = this.isOnGround;
            }
        }

        class Population {
            constructor(size) {
                this.size = size;
                this.players = Array(size).fill().map(() => new AIPlayer());
                this.generation = 1;
                this.bestPlayer = null;
                this.bestScore = 0;
                this.stagnantGenerations = 0;
                this.lastBestScore = 0;
                this.speciesList = [];
                this.innovationHistory = [];
            }

            update() {
                let allDone = true;
                const currentTime = Date.now();
                
                this.players.forEach(player => {
                    // Force new generation after 10 seconds
                    if (currentTime - player.startTime > 10000) {
                        player.dead = true;
                        return;
                    }

                    if (!player.dead && !player.reachedGoal) {
                        allDone = false;
                        const decision = player.think(this.getGameState());
                        this.applyDecision(player, decision);
                    }
                });

                if (allDone || (currentTime - this.players[0].startTime > 30000)) {
                    return true;
                }

                return false;
            }

            getGameState() {
                return {
                    platforms,
                    lavaBlocks,
                    goal,
                    currentLevel
                };
            }

            calculateAverageFitness() {
                return this.players.reduce((sum, player) => sum + player.fitness, 0) / this.players.length;
            }

            applyDecision(player, decision) {
                // Simulate your game's physics for the AI player
                const prevX = player.position.x;
                if (decision.left) {
                    player.velocity.x = -MOVE_SPEED;
                    player.facingRight = false;
                } else if (decision.right) {
                    player.velocity.x = MOVE_SPEED;
                    player.facingRight = true;
                }

                if (decision.jump) {
                    if (player.isOnGround) {
                        player.velocity.y = -JUMP_FORCE;
                    } else if (player.canDoubleJump) {
                        player.velocity.y = -JUMP_FORCE;
                        player.canDoubleJump = false;
                    }
                }

                if (decision.dash && player.canDash && !player.isDashing) {
                    player.isDashing = true;
                    player.canDash = false;
                    player.velocity.x *= 2;
                    player.dashCount++; // Increment dash counter
                    setTimeout(() => {
                        player.isDashing = false;
                    }, 300);
                }

                // Apply physics
                player.velocity.y += GRAVITY;
                player.position.x += player.velocity.x;
                player.position.y += player.velocity.y;

                // Check collisions
                this.handleCollisions(player);
            }

            handleCollisions(player) {
                // Platform collisions
                player.isOnGround = false;
                platforms.forEach(platform => {
                    if (this.checkCollision(player, platform)) {
                        // Apply your game's collision resolution logic
                        const overlapX = Math.min(
                            Math.abs(player.position.x + player.width - platform.position.x),
                            Math.abs(platform.position.x + platform.width - player.position.x)
                        );
                        const overlapY = Math.min(
                            Math.abs(player.position.y + player.height - platform.position.y),
                            Math.abs(platform.position.y + platform.height - player.position.y)
                        );

                        if (overlapX < overlapY) {
                            // Horizontal collision
                            if (player.position.x < platform.position.x) {
                                player.position.x = platform.position.x - player.width;
                            } else {
                                player.position.x = platform.position.x + platform.width;
                            }
                            if (player.isDashing) {
                                player.isDashing = false;
                            }
                        } else {
                            // Vertical collision
                            if (player.position.y < platform.position.y) {
                                player.position.y = platform.position.y - player.height;
                                player.velocity.y = 0;
                                player.isOnGround = true;
                                player.canDoubleJump = true;
                                player.canDash = true;
                            } else {
                                player.position.y = platform.position.y + platform.height;
                                player.velocity.y = 0;
                            }
                        }
                    }
                });

                // Goal collision
                if (this.checkCollision(player, goal)) {
                    player.reachedGoal = true;
                    if (player.calculateFitness() > this.bestScore) {
                        this.bestScore = player.fitness;
                        this.bestPlayer = player;
                    }
                }

                // Lava collision
                lavaBlocks.forEach(lava => {
                    if (this.checkCollision(player, lava)) {
                        player.dead = true;
                    }
                });

                // Boundary checks
                if (player.position.x < 0 || 
                    player.position.x + player.width > 1200 || 
                    player.position.y < 0 || 
                    player.position.y > 800) {
                    player.dead = true;
                }
            }

            checkCollision(a, b) {
                return a.position.x < b.position.x + b.width &&
                    a.position.x + a.width > b.position.x &&
                    a.position.y < b.position.y + b.height &&
                    a.position.y + a.height > b.position.y;
            }

            naturalSelection() {
                // Calculate fitness for all players
                this.players.forEach(player => player.calculateFitness());
                
                // Sort by fitness
                this.players.sort((a, b) => b.fitness - a.fitness);
                
                // Species separation
                this.speciesList = this.separateIntoSpecies();
                
                // Create new population with species
                const newPlayers = [];
                
                // Elitism - keep best performers from each species
                this.speciesList.forEach(species => {
                    if (species.length > 5) {
                        newPlayers.push(species[0].clone());
                    }
                });
                
                // Fill remaining population
                while (newPlayers.length < this.size) {
                    // Select species based on fitness
                    const species = this.selectSpecies();
                    
                    // Tournament selection within species
                    const parent1 = this.tournamentSelect(species);
                    const parent2 = this.tournamentSelect(species);
                    
                    // Create child with crossover
                    const child = this.crossover(parent1, parent2);
                    
                    // Adaptive mutation
                    const mutationRate = Math.min(0.3, 0.1 + (this.stagnantGenerations * 0.02));
                    child.brain.mutate(mutationRate);
                    
                    newPlayers.push(child);
                }
                
                this.players = newPlayers;
                this.generation++;
            }

            separateIntoSpecies() {
                // Implement species separation based on neural network similarity
                // This helps maintain diversity in the population
                const species = [];
                const threshold = 0.3; // Similarity threshold
                
                this.players.forEach(player => {
                    let foundSpecies = false;
                    for (const speciesGroup of species) {
                        if (this.isSimilar(player, speciesGroup[0], threshold)) {
                            speciesGroup.push(player);
                            foundSpecies = true;
                            break;
                        }
                    }
                    if (!foundSpecies) {
                        species.push([player]);
                    }
                });
                
                return species;
            }

            isSimilar(player1, player2, threshold) {
                // Calculate similarity based on neural network weights
                let totalDiff = 0;
                let weightCount = 0;
                
                // Compare hidden layer weights
                player1.brain.weights_ih.forEach((row, i) => {
                    row.forEach((weight, j) => {
                        totalDiff += Math.abs(weight - player2.brain.weights_ih[i][j]);
                        weightCount++;
                    });
                });
                
                // Compare output layer weights
                player1.brain.weights_ho.forEach((row, i) => {
                    row.forEach((weight, j) => {
                        totalDiff += Math.abs(weight - player2.brain.weights_ho[i][j]);
                        weightCount++;
                    });
                });
                
                const avgDiff = totalDiff / weightCount;
                return avgDiff < threshold;
            }

            tournamentSelect(species) {
                const tournamentSize = Math.min(5, species.length);
                const tournament = Array(tournamentSize).fill()
                    .map(() => species[Math.floor(Math.random() * species.length)]);
                return tournament.reduce((best, current) => 
                    current.fitness > best.fitness ? current : best
                );
            }

            crossover(parent1, parent2) {
                const child = new AIPlayer();
                
                // Weighted average crossover
                for (let i = 0; i < parent1.brain.weights_ih.length; i++) {
                    for (let j = 0; j < parent1.brain.weights_ih[i].length; j++) {
                        const weight = Math.random() < 0.5 ? 
                            parent1.brain.weights_ih[i][j] : 
                            parent2.brain.weights_ih[i][j];
                        child.brain.weights_ih[i][j] = weight;
                    }
                }
                
                for (let i = 0; i < parent1.brain.weights_ho.length; i++) {
                    for (let j = 0; j < parent1.brain.weights_ho[i].length; j++) {
                        const weight = Math.random() < 0.5 ? 
                            parent1.brain.weights_ho[i][j] : 
                            parent2.brain.weights_ho[i][j];
                        child.brain.weights_ho[i][j] = weight;
                    }
                }
                
                return child;
            }
        }

        // Training system setup
        const trainingSystem = new Population(500);

        // Main training loop
        function trainAI() {
            if (trainingSystem.update()) {
                console.log(`Generation ${trainingSystem.generation} complete`);
                console.log(`Best fitness: ${trainingSystem.bestScore}`);
                
                if (trainingSystem.bestScore > 0.9) {
                    console.log("Level completed! Moving to next level...");
                    currentLevel++;
                    createLevel(currentLevel);
                }
                
                trainingSystem.naturalSelection();
            }
            
            requestAnimationFrame(trainAI);
        }

        // Start training
        trainAI();

        // Training System class
        class TrainingSystem {
            constructor(populationSize = 50) {
                this.population = new Population(populationSize);
                this.currentLevel = 1;
                this.gameState = this.createGameState(this.currentLevel);
                this.generationStats = [];
                this.levelStartTime = Date.now();
                this.highestLevelReached = 1;
            }

            createGameState(level) {
                // Reset the game state for the new level
                createLevel(level);
                currentLevel = level; // Update the global currentLevel
                
                return {
                    platforms: platforms,
                    lava: lavaBlocks,
                    goal: goal,
                    nearestPlatform: this.findNearestPlatform({ x: spawnPoint.x, y: spawnPoint.y }, platforms)
                };
            }

            findNearestPlatform(position, platforms) {
                return platforms.reduce((nearest, platform) => {
                    const distance = Math.sqrt(
                        Math.pow(platform.x + platform.width/2 - position.x, 2) +
                        Math.pow(platform.y - position.y, 2)
                    );
                    return distance < nearest.distance ? {
                        x: platform.x + platform.width/2,
                        y: platform.y,
                        distance
                    } : nearest;
                }, { x: 0, y: 0, distance: Infinity });
            }

            update() {
                const allDone = this.population.update(this.gameState);
                
                // Check if any player reached the goal
                const goalReached = this.population.players.some(player => player.reachedGoal);
                
                if (goalReached && this.currentLevel === currentLevel) {
                    // Update highest level reached if necessary
                    this.highestLevelReached = Math.max(this.highestLevelReached, this.currentLevel + 1);
                    this.currentLevel++;
                    this.gameState = this.createGameState(this.currentLevel);
                    this.levelStartTime = Date.now();
                    
                    // Reset all players for the new level
                    this.population.players.forEach(player => this.resetPlayer(player));
                }

                if (allDone) {
                    const stats = {
                        generation: this.population.generation,
                        bestFitness: this.population.bestScore,
                        averageFitness: this.population.calculateAverageFitness(),
                        currentLevel: this.currentLevel,
                        highestLevelReached: this.highestLevelReached,
                        goalReached: goalReached
                    };
                    
                    // Store the current best player's brain before reset
                    const bestBrain = this.population.bestPlayer ? this.population.bestPlayer.brain.clone() : null;
                    
                    // Perform natural selection
                    this.population.naturalSelection();
                    
                    // Reset to level 1 for the new generation
                    this.currentLevel = 1;
                    this.gameState = this.createGameState(1);
                    
                    // Reset all players but preserve the best brain for learning
                    this.population.players.forEach(player => {
                        this.resetPlayer(player);
                        if (bestBrain) {
                            // Clone the best brain with some mutation for each player
                            player.brain = bestBrain.clone();
                            player.brain.mutate(0.1); // 10% mutation rate
                        }
                    });
                    
                    this.generationStats.push(stats);
                    
                    return stats;
                }
                return null;
            }

            resetPlayer(player) {
                player.position = { x: spawnPoint.x, y: spawnPoint.y };
                player.velocity = { x: 0, y: 0 };
                player.dead = false;
                player.reachedGoal = false;
                player.startTime = Date.now();
                player.dashCount = 0;
                player.isOnGround = false;
                player.canDoubleJump = true;
                player.canDash = true;
                player.isDashing = false;
            }

            getStats() {
                return this.generationStats;
            }

            getBestPlayer() {
                return this.population.bestPlayer;
            }

            reset() {
                this.currentLevel = 1;
                this.gameState = this.createGameState(this.currentLevel);
                this.population = new Population(this.population.players.length);
                this.generationStats = [];
                this.highestLevelReached = 1;
            }
        }

        const GameCanvas = ({ gameState, population }) => {
            const canvasRef = React.useRef(null);
            const animationFrameRef = React.useRef(null);

            const draw = React.useCallback(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw platforms
                ctx.fillStyle = '#333';
                platforms.forEach(platform => {
                    ctx.fillRect(
                        platform.position.x,
                        platform.position.y,
                        platform.width,
                        platform.height
                    );
                });

                // Draw lava
                ctx.fillStyle = '#ff4444';
                lavaBlocks.forEach(lava => {
                    ctx.fillRect(
                        lava.position.x,
                        lava.position.y,
                        lava.width,
                        lava.height
                    );
                });

                // Draw goal
                ctx.fillStyle = '#44ff44';
                ctx.fillRect(
                    goal.position.x,
                    goal.position.y,
                    goal.width,
                    goal.height
                );

                // Draw AI players
                population.players.forEach(player => {
                    if (!player.dead) {
                        ctx.fillStyle = player.reachedGoal ? '#44ff44' : '#4444ff';
                        ctx.fillRect(
                            player.position.x,
                            player.position.y,
                            player.width,
                            player.height
                        );
                    }
                });
            }, [gameState, population]);

            React.useEffect(() => {
                const animate = () => {
                    draw();
                    animationFrameRef.current = requestAnimationFrame(animate);
                };
                
                animate();
                
                return () => {
                    if (animationFrameRef.current) {
                        cancelAnimationFrame(animationFrameRef.current);
                    }
                };
            }, [draw]);

            return (
                <canvas
                    ref={canvasRef}
                    width={CANVAS_WIDTH}
                    height={CANVAS_HEIGHT}
                    className="border border-gray-300 bg-white"
                />
            );
        };

        const AITrainer = () => {
            const [generation, setGeneration] = React.useState(1);
            const [isTraining, setIsTraining] = React.useState(false);
            const [speed, setSpeed] = React.useState(1);
            const [stats, setStats] = React.useState({
                averageFitness: 0,
                bestFitness: 0,
                goalReached: false,
                generation: 1,
                currentLevel: 1,
                highestLevelReached: 1
            });
            const [allTimeStats, setAllTimeStats] = React.useState([]);
            const trainingSystemRef = React.useRef(new TrainingSystem(50));
            const animationFrameRef = React.useRef(null);

            const updateSimulation = React.useCallback(() => {
                if (!isTraining) return;

                for (let i = 0; i < speed; i++) {
                    const newStats = trainingSystemRef.current.update();
                    if (newStats) {
                        setStats(newStats);
                        setAllTimeStats(prev => [...prev, newStats]);
                        setGeneration(newStats.generation);
                    }
                }
                
                animationFrameRef.current = requestAnimationFrame(updateSimulation);
            }, [isTraining, speed]);

            React.useEffect(() => {
                if (isTraining) {
                    updateSimulation();
                } else if (animationFrameRef.current) {
                    cancelAnimationFrame(animationFrameRef.current);
                }

                return () => {
                    if (animationFrameRef.current) {
                        cancelAnimationFrame(animationFrameRef.current);
                    }
                };
            }, [isTraining, updateSimulation]);

            return (
                <div className="flex flex-col gap-8">
                    <Card className="w-full max-w-6xl mx-auto">
                        <CardHeader>
                            <CardTitle>
                                AI Training Progress - Generation {generation}
                                <span className="ml-4 text-gray-600">
                                    Current Level: {stats.currentLevel} | Best Level: {stats.highestLevelReached}
                                </span>
                            </CardTitle>
                        </CardHeader>
                        <CardContent>
                            <div className="flex flex-col gap-4">
                                <div className="flex gap-4 items-center">
                                    <button 
                                        className="p-2 bg-blue-500 text-white rounded"
                                        onClick={() => setIsTraining(!isTraining)}
                                    >
                                        {isTraining ? "Pause" : "Play"}
                                    </button>
                                    <button 
                                        className="p-2 bg-green-500 text-white rounded"
                                        onClick={() => setSpeed(s => Math.min(s * 2, 16))}
                                    >
                                        Speed Up
                                    </button>
                                    <span>Speed: {speed}x</span>
                                </div>

                                <div className="stats grid grid-cols-4 gap-4">
                                    <div className="stat bg-gray-100 p-4 rounded">
                                        <div className="text-lg">Average Fitness</div>
                                        <div className="text-2xl">{stats.averageFitness.toFixed(4)}</div>
                                    </div>
                                    <div className="stat bg-gray-100 p-4 rounded">
                                        <div className="text-lg">Best Fitness</div>
                                        <div className="text-2xl">{stats.bestFitness.toFixed(4)}</div>
                                    </div>
                                    <div className="stat bg-gray-100 p-4 rounded">
                                        <div className="text-lg">Goals Reached</div>
                                        <div className="text-2xl">{allTimeStats.filter(s => s.goalReached).length}</div>
                                    </div>
                                    <div className="stat bg-gray-100 p-4 rounded">
                                        <div className="text-lg">Current Level</div>
                                        <div className="text-2xl">{currentLevelReached}</div>
                                    </div>
                                </div>

                                </div>

                                <GameCanvas 
                                    gameState={trainingSystemRef.current.gameState}
                                    population={trainingSystemRef.current.population}
                                />

                                <div style={{ width: '100%', height: 300 }}>
                                    <ResponsiveContainer>
                                        <LineChart data={allTimeStats}>
                                            <CartesianGrid strokeDasharray="3 3" />
                                            <XAxis dataKey="generation" />
                                            <YAxis />
                                            <Tooltip />
                                            <Legend />
                                            <Line type="monotone" dataKey="averageFitness" stroke="#8884d8" />
                                            <Line type="monotone" dataKey="bestFitness" stroke="#82ca9d" />
                                        </LineChart>
                                    </ResponsiveContainer>
                            </div>
                        </CardContent>
                    </Card>
                </div>
            );
        };

        // Simple Card components remain the same
        const Card = ({ children, className = "" }) => (
            <div className={`bg-white rounded-lg shadow ${className}`}>{children}</div>
        );

        const CardHeader = ({ children }) => (
            <div className="p-6 border-b">{children}</div>
        );

        const CardTitle = ({ children }) => (
            <h2 className="text-2xl font-bold">{children}</h2>
        );

        const CardContent = ({ children }) => (
            <div className="p-6">{children}</div>
        );

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<AITrainer />);
    </script>
</body>
</html>